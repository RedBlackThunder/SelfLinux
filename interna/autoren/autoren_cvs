
Autoren CVS
-------------

Arbeit der Autoren mit dem SelfLinux-CVS

Stand: 26.12.2003		$Revision: 1.10 $



1 Einleitung

Wer noch NIE mit CVS gearbeitet hat, sollte diesen Text erstmal
insgesamt durchlesen und erst dann ans experimentieren gehen!

Für unserer Texte verwenden wir das CVS (Concurrent Versions System)
als Versionsverwaltungssystem. CVS ist ein geniales Werkzeug. Es
ermöglicht zwei Dinge. Zum einen die Historienverwaltung von Dateien
und zum anderen die Zusammenarbeit von mehreren Personen an diesen
Dateien. Wenn du mehr über das CVS erfahren willst, dann lies doch mal
die CVS-Kapitel in SelfLinux. Diese sind zwar sehr umfangreich, aber auch
sehr interessant.

Hier soll lediglich gezeigt werden, welche cvs-Befehle die
Autoren für alltägliche Arbeit benötigen und auf was geachtet werden
sollte. Alle hier dargestellten Befehle werden in einer Konsole
(shell) ausgeführt.

Es gibt einige grafische Programme für CVS, wie Cervisia oder
LinCVS. Diese werden hier nicht erklärt! Sie verwenden im Hintergrund
genau dieselben Befehle, wie sie in einer Konsole eingegeben
werden. Wenn du solche Programme benutzen möchtest, dann informiere
dich in der entsprechenden Programm-Dokumentation. 



2 Allgemein Regeln



2.1 Wohin mit den Texten?

Prinzipiell wird jeder NEUE Text erst einmal ins Sammelbecken
eingecheckt. Dies dient dazu, um eine gewisse Übersicht und Ordnung
über unsere Texte zu behalten. Also bitte daran halten!

Also jeder Text, der noch durch die einzelnen Arbeitsschritte QA1, Layout,
QA2 muss, gehört somit ins Sammelbecken. Du darfst hier als Autor ein
Unterverzeichnis für deinen Text anlegen. In dieses Verzeichnis kommt
der Text. Verzeichnis- und Textnamen sind klein zu schreiben und die
Namen sollen dieselben sein. Wenn es mehrere  Textdateien gibt, dann
sollte zumindest die "Masterdatei" den gleichen Namen wie das
Verzeichnis haben. An die Textdateien bitte KEINE Dateierweiterungen
(z.B. *.txt) hängen.
Empfohlen wird, die Verzeichnisnamen dem späteren Ablageort im
Tutorial anzupassen.

Beispiel:
Tutorialkapitel: Anwendungssoftware->LaTeX->Kile
Verzeichnisname: latex_kile
Dateiname: latex_kile
(siehe auch das CVS)



2.1 Wohin mit den Bildern?

Bilder sollen als zum Text gehörend wiedererkannt werden. Um das
sicherzustellen wird unter /sammelbecken/bilder/ ein gleichbenanntes
(wie bei den Texten) Verzeichnis angelegt, in das die entsprechenden Bilder
abgespeichert werden.

Beispiel (von oben):
Verzeichnisname: sammelbecken/bilder/latex_kile/
Dateinamen: neuer_artikel.png, schnellstart.png, ...

Die Bildernamen sollten möglichst aussagekräftig nach dem Inhalt des
Bildes benannt werden, also NICHT z.B. bild1.png; bild2.png oder
ähnliches. Als Bildformat ist PNG zu verwenden. 



3 Vorbereitungen



3.1 Schreibzugriff erhalten

Nach der Anmeldung bei SelfLinux besitzt jeder Autor einen
Benutzernamen und ein Passwort für den Intern-Bereich. Diese
Zugangsdaten gelten später auch für den CVS-Zugriff.

Den Schreibzugriff aufs CVS muss aber der Teamleiter extra
aktivieren. Daher bitte den Teamleiter wegen dem Schreibzugriff
kontaktieren. Auch wenn etwas nicht funktioniert - fragen!

Bei Mitgliedern mit dem Zeitstatus "derzeit nicht verfügbar" und "ewig
nichts gehört" wird der Schreibzugriff deaktiviert!



3.2 Zugang zum CVS

Für den Zugriff (Login) auf das SelfLinux-CVS-Repository auf
pingos.org gibt es mehrere Möglichkeiten:

(Befehle auf einer Konsole [user$] bei bestehender
Internet-Verbindung eintippen)

Anonym:
user$ cvs -d :pserver:anonymous@cvs.pingos.org:/selflinux login
	-> das Password ist leer!

Als SL-Mitglied OHNE Verschlüsselung (NICHT empfohlen):
user$ cvs -d :pserver:<SelfLinux_Username>@cvs.pingos.org:/selflinux login
	-> Password wie bei MySelfLinux (Internbereich)

Als SL-Mitglied MIT Verschlüsselung (EMPFOHLEN):
(hier wird als Zusatzprogramm das Programm "stunnel" verwendet)
user$ stunnel -P /tmp -c -d 2401 -r cvs.pingos.org:2402
user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux login
	-> Password wie bei MySelfLinux (Internbereich)

Über Web:
http://cvs.pingos.org/cgi-bin/viewcvs.cgi/?cvsroot=selflinux

-----------------------------------------------------------------

*ACHTUNG!* Der hier beschriebene stunnel-Befehl funktioniert nur mit den
3.x -Versionen von stunnel. Bei neuen 4.x -Versionen von stunnel sind
die Konfiguration und die Befehle völlig abgeändert wurden und diese
Versionen funktionieren daher nicht mit dem oben angeführten Befehl.

Für <SelfLinux_Username> wird natürlich der eigene SL-Name
eingesetzt. Es kann auch sein das bei stunnel der absolute Pfad
angegeben werden muss (z.B. /usr/sbin/stunnel), also ggf. ausprobieren.

Wenn man Dateien ins CVS schreiben will, geht das nur mit den zwei
Zugangsarten, wo der Username angegeben werden muss. (Logisch! Sonst
könnte ja jeder in unserem CVS rumschreiben.)



3.3 Checkout der Arbeitskopie

Um mit dem CVS arbeiten zu können, braucht man immer eine eigene,
lokale Arbeitskopie. In dieser Arbeitskopie werden dann die
entsprechenden Dateien bearbeitet und die Änderungen dann dem
CVS-Repository mitgeteilt. Also besorgst du dir erst einmal eine
Arbeitskopie.

Dazu legst du dir ein Verzeichnis an, wo die Arbeitskopie
abgespeichert werden soll, z.B. /home/<username>/selflinux/cvs oder
ähnliches. 
Dann wechselst du in dieses Verzeichnis:

user$ cd /home/<username>/selflinux/cvs

Als nächstes logst du dich als SelfLinux-Mitglied wie oben beschrieben
in das Pingos.org-CVS ein. Mit folgenden Befehl wird das gesamte
SL-Repository als Arbeitskopie "ausgecheckt":

Als SL-Mitglied OHNE Verschlüsselung:
user$ cvs -d :pserver:<SelfLinux_Username>@cvs.pingos.org:/selflinux co . 

(Hinter dem "co" steht ein Punkt als Zeichen für das Auschecken des
gesamten CVS!)

Als SL-Mitglied MIT Verschlüsselung:
user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux co . 

Wenn du nur ein einzelnes Modul möchtest, z.B. das Tutorial, dann gibt
man hinter dem "co" den Verzeichnisnamen an, unser Bsp.:

user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux co tutorial

Diesen Checkout der Arbeitskopie macht man eigentlich nur
einmal. Später wird die Arbeitskopie durch den "cvs update"-Befehl
aktualisiert.

TIPS!
Nach dem ersten Einloggen werden in der .cvspass-Datei, die im
Home-Verzeichnis angelegt wird, die Zugangsdaten zum CVS-Server
abgelegt. Wenn man die Arbeitskopie noch geholt hat, ist dann das
CVS so klug und sucht sich zu der Arbeitskopie den passenden
Server. Damit sind die hier aufgeführten Schritte bei der späteren
Arbeit mit CVS normalerweise nicht mehr notwendig.

Es ist auch möglich, eine Datenkompression für die Verbindungen zum
Server einzustellen. Dazu wird hinter dem Befehl cvs die Option -z und
eine Zahl zwischen eins (minimale Kompression) und neun (maximale
Kompression) gesetzt. Als praktikabel haben sich Zahlen zwischen drei
und fünf herausgestellt. Das Kommando sehe also mit Kompression dann
so aus (Beispiel):

user$ cvs -z3 -d :pserver:<SelfLinux_Username>@localhost:/selflinux co .

Am besten ist, einfach mal mit den Zahlen herumzuexperimentieren
(sofern man diese Option nutzen will).


 
3.4 Zusammenfassung
 
Zur besseren Veranschaulichung soll an einem Beispiel diese
Anfangssitzung noch mal zusammengefasst gezeigt werden. Wir gehen davon
aus, daß wir den Zugang mit Verschlüsselung haben wollen und als Autor
benötigen wir erstmal nur das Sammelbecken. Damit werden folgende
Befehle eingegeben:

user$ cd /home/<username>/selflinux/cvs
user$ stunnel -P /tmp -c -d 2401 -r cvs.pingos.org:2402
user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux login
password CVS:  -> Passwort eingeben!
user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux co sammelbecken



4. "Alltägliche" Arbeit mit dem CVS



4.1 Anlegen eines neuen Textes

Jetzt wollen wir in das Sammelbecken einen neuen Text anlegen. Dazu
gehen wir in das Verzeichnis unserer (ausgecheckten) lokalen
Arbeitskopie.

user$ cd /home/<username>/selflinux/cvs/sammelbecken

Dort müssen wir zuerst ein Verzeichnis mit dem Namen für den neuen
Text anlegen. 

user$ mkdir <neuer_text>
(Achtung! Das ist ein Verzeichnis, keine Datei!)

Als nächstes muss dieses Verzeichnis unserem CVS-Repository bekannt
gemacht werden. Das erfolgt mit dem Befehl:

user$ cvs add <neuer_text>

Damit haben wir in unserem CVS ein neues Verzeichnis im Sammelbecken
angelegt.

WICHTIGER HINWEIS!
Eimal eingecheckte Verzeichnisse können NICHT mehr aus dem
CVS-Repository entfernt werden. Darum bitte vor dem "cvs add"-Befehl
unbedingt noch mal GENAU prüfen, ob das Verzeichnis an der richtigen
Stelle in der Arbeitskopie erzeugt wurde. Der "cvs add"-Befehl ist bei
Verzeichnissen daher mit GRÖSSTER Sorgfalt anzuwenden!

Nun wechselt man in das neue Verzeichnis und kopiert seinen Text
hinein.

user$ cd <neuer_text>
user$ cp <Quelldatei> <Zieldatei>

(Wie man das hier reinkopiert, ist natürlich jedem selbst überlassen.)

Auch hier müssen wir unsere Textdatei dem CVS bekannt machen. Aber im
Unterschied zu einem Verzeichnis erfolgt das bei Dateien in zwei
Schritten:

user$ cvs add <neuer_text>
user$ cvs commit -m "Text ueber ... eingefuegt" <neuer_text>

Damit wird unser neuer Text endgültig in unser CVS-Repository
eingefügt.

Hinweise zum "cvs commit"-Befehl.

Das "commit" kann man abkürzen, in dem man z.B.:

user$ cvs ci -m "..." <Datei>

eingibt.

Mit -m "<Kommentar>" wird ein Kommentar in das log-file
abgelegt. Hier sollte sehr kurz und prägnant reingeschrieben werden,
was man an der Datei gemacht hat (z.B. Rechtschreibfehler korrigiert
oder um Kapitel soundso erweitert). Bloß keine Romane schreiben! Man
kann diese Option auch weglassen, dann öffnet sich beim Absetzen des
Befehls ein Editor-Fenster, wo man diesen Einzeiler reinschreiben
muss. Mit -m geht das halt einfach schneller.



4.2 Ablegen von Bildern eines Textes

Bilder werden immer in dem Verzeichnis /sammelbecken/bilder
abgelegt. Die Schritte sind analog zu den Texten. Wir legen wieder ein
Verzeichnis mit demselben Namen wie beim Text an:

user$ cd /<Pfad>/sammelbecken/bilder
user$ mkdir <neuer_text>
user$ cvs add <neuer_text>

(Achtung, das ist ein Verzeichnis, also bitte sorgfältig noch mal
alles überprüfen!)

In das Verzeichnis wechseln:

user$ cd <neuer_text>

Nun werden die Bilder hinzugefügt. Dazu gibt es folgende Besonderheit
zu beachten. Bilder müssen beim "cvs add"-Befehl mit der Option -kb
eingecheckt werden. CVS wurde ursprünglich für reine Textdateien
entwickelt. Bilddateien sind aber Binärdateien, daher werden mit "-kb"
u.a. die Schlüsselwort-Ersetzungen unterdrückt, was damit ein
unverändertes Einchecken der Bilder ermöglicht.
Wer mehr darüber wissen möchte, sollte sich die CVS-Kapitel in SL
durchlesen. 

user$ cvs add -kb bildname.png

Wenn man mehrere Bilder hat, kann man diese natürlich auch mit einem
Male einchecken.

user$ cvs add -kb bildname1.png bildname2.png bildname3.png

usw.

Abschließend müssen die Bilder wie die Textdateien auch ins CVS mit
"commit" eingefügt werden.

user$ cvs commit -m "Bild soundso eingecheckt" bildname.png

Wenn man gleich mehrere Bilder ins Verzeichnis eingefügt hat, dann
braucht man die Dateinamen nicht noch mal einfügen, es reicht:

user$ cvs ci -m "Bilder eingecheckt"



4.3 Bearbeiten eines vorhandenen Textes

Wir geben unseren "stunnel"-Befehl ein und wechseln dann in das
Verzeichnis, wo unser Text liegt, den wir bearbeiten wollen:

user$ cd /<Pfad>/sammelbecken/<text>

Dann wird als erstes immer ein:

user$ cvs update

gemacht. Mit cvs update wird verglichen, ob die lokale Arbeitskopie
und das CVS-Repository noch gleich sind und ggf. abgeglichen. 

Um dem CVS und damit anderen Mitarbeitern, die eventuell mit dem Text
befasst sind, mitzuteilen, dass der Text gerade bearbeitet wird,
markiert man ihn entsprechend:

user$ cvs edit <text>

Diese Markierung wird beim nächsten Commit automatisch
aufgehoben. Jetzt können wir mit unserem Lieblingseditor die Datei
bearbeiten:

user$ EDITOR <text>

Nach der Bearbeitung müssen wir unsere Änderungen wieder ins CVS
einfügen:

user$ cvs commit -m "Ergänzungen zu ... angebracht" <text>

oder kürzer ;)

user$ cvs ci -m "Ergänzungen zu ... angebracht"

Dieser Zyklus (siehe auch unten bei Zusammenfassung) sollte bei jeder
neuen Bearbeitung der Datei erneut durchlaufen werden!

TIP!
Falls man die Datei nicht mit "commit" ins CVS bringen möchte, aber
ein "cvs edit" gemacht hat, dann kann man mit dem Befehl "cvs unedit
<text>" die Markierung durch edit wieder aufheben.



4.4 Besonderheiten bei der Verwaltung von Verzeichnissen

Bei der Verwaltung von Verzeichnissen gibt es einige merkwürdige
Besonderheiten bei CVS, die beachtet werden müssen.

Möchte man ein Verzeichnis entfernen, muss man zuerst alle darin
enthaltenen Dateien löschen.

user$ rm <datei1> <datei2>
user$ cvs remove <datei1> <datei2>
(zwei remove Befehle!)

Dies muss durch ein commit auch dem Repository mitgeteilt werden (wie
bei Dateien üblich).

user$ cvs ci -m "alle Dateien gelöscht" <datei1> <datei2>

Dann kommt das Besondere! Man muss jetzt:

user$ cvs update -P

machen. Die "-P" Option bedeutet für update, leere Verzeichnisse zu
reduzieren. Aber Achtung! Es bleibt im CVS-Repository ein leeres
Verzeichnis stehen (wie oben schon gesagt), das leere Verzeichnis wird
jetzt (nur) aus der lokalen Arbeitskopie entfernt.

Ein interessantes Gegenstück zu diesem Verhalten ist, dass das CVS bei
einem einfachen "update" keine neuen Verzeichnisse aus dem
CVS-Repository in die Arbeitskopie einfügt! Darum sollte man in
regelmäßigen Abständen seine Module oder die gesamte Arbeitskopie mit
"cvs update -P" aktualisieren, so das eventuell neue Verzeichnisse
in die lokale Arbeitskopie aufgenommen werden.  



5. Zusammenfassung

Hier nochmal eine Zusammenfassung der wichtigsten Befehle (in
Kurzform).

Zugang CVS:

Diesen Befehl immer am Anfang der Onlinesitzung EINMAL eingeben. Dann
arbeitet man mit dem CVS über die verschlüsselte Verbindung.

user$ stunnel -P /tmp -c -d 2401 -r cvs.pingos.org:2402

Anlegen eines neuen Textes:

user$ cd /<Pfad>/sammelbecken
user$ mkdir <neuer_text>
user$ cvs add <neuer_text>
(Verzeichnis erstellt)

user$ cd <neuer_text>
user$ cp <Quelldatei> <Zieldatei>
user$ cvs add <neuer_text>
user$ cvs ci -m "Text ueber ... eingefuegt" <neuer_text>
(Text eingefügt)

Bilder anlegen:

user$ cd /<Pfad>/sammelbecken/bilder
user$ mkdir <neuer_text>
user$ cvs add <neuer_text>
(Verzeichnis erstellt)

user$ cd <neuer_text>
user$ cvs add -kb bildname1.png bildname2.png bildname3.png
user$ cvs ci -m "Bilder eingecheckt"
(Bilder eingefügt)

Vorhandenen Text bearbeiten:

-ins Verzeichnis gehen (wo der Text sich befindet)
user$ cvs update
user$ cvs edit <text>
user$ EDITOR <text> 
user$ cvs ci -m "Ergänzungen zu ... angebracht" <text>


Wie man anhand der Zusammenfassung schön sehen kann, ist der Umgang
mit CVS nicht so schwierig. Es ist einfach eine Übungssache, um die
entsprechenden Befehle zu tippen.

Wenn Fragen oder Unklarheiten sind, dann bitte einfach eine E-Mail an
die Mailingliste. CVS erscheint einem anfangs als schwierig, darum lieber
zuviel gefragt als zuwenig. ;)



6. Üben und Testen

In unserem CVS-Repository gibt es zum Üben ein
"test"-Verzeichnis. Dieses Verzeichnis kann als Modul "test"
ausgecheckt werden, also z.B. so (mit Verschlüsselung):

user$ cvs -d :pserver:<SelfLinux_Username>@localhost:/selflinux co test

Unter:

http://cvs.pingos.org/cgi-bin/viewcvs.cgi/test/

kann man sich das Verzeichnis ansehen. In dem Testverzeichnis
befindet sich ein "autoren"-Verzeichnis. In diesem Verzeichnis (und
nur in diesem - also bitte genau aufpassen!!!) darf jeder Autor, der
mit CVS abeiten möchte, EIN Verzeichnis mit seinem SelfLinux_Usernamen
einrichten. In diesem persönlichen Verzeichnis kann er dann nach
Herzenslust üben und dort Dateien einchecken, abändern, commiten und
was es sonst noch so gibt. Damit hat man einfach die Möglichkeit, sich
an den Umgang mit dem CVS zu gewöhnen. Nutzt diese Möglichkeit!



7. Spezialfälle



7.1 Konflikte

Etwas womit Autoren eigentlich nur sehr selten in Berührung kommen
sollten, sind Konflikte. Konflikte treten auf, wenn sowohl die
Arbeitskopie als auch die Datei im Repository in der gleichen Zeile
geändert wurden und ein Commit von der lokalen Arbeitskopie versucht
wird.

Dazu soll uns ein Beispiel dienen:

Dazu wird ein Abschnitt aus dem Text "cron" verwendet.

Angenommen wir haben in unserer Arbeitskopie die 
Revision ( Version) 1.2 .
Währenddessen hat ein anderer ein paar Rechtschreibfehler aus dieser
1.2 entfernt und diese Änderungen ins CVS eingecheckt. Damit entstand
eine neue Revision 1.3 . Später machen wir noch ein paar inhaltliche
Änderungen und zufälligerweise auch genau da, wo Rechtschreibfehler
gewesen sind. Da wir etwas "faul" waren, haben wir vorher kein "cvs
update" gemacht, sondern wollen die Datei gleich ins CVS einchecken.
Also ein:

user$ cvs ci -m "inhaltliche Aenderung" cron

eingegeben. Folgende Ausgabe erscheint da:

cvs commit: Up-to-date check failed for `cron'
cvs [commit aborted]: correct above errors first!

Das CVS meckert, das wir die Update-Überprüfung vergessen haben! Also
machen wir das doch:

user$ cvs update cron

Oh Schreck! Jetzt erhalten wir folgende Ausgabe:

RCS file: /<Pfad>/tutorial/cron,v
retrieving revision 1.2
retrieving revision 1.3
Merging differences between 1.2 and 1.3 into cron
rcsmerge: warning: conflicts during merge
cvs update: conflicts found in cron
C cron

CVS teilt uns jetzt mit, das zwischen unserer 1.2 und der 1.3 im CVS
"Konflikte" entstanden sind. Das macht CVS deshalb, weil es ja nicht
weiß, welcher Text in den beiden Versionen nun der richtige Text
ist. Damit fordert uns CVS auf, den richtigen Text MANUELL
einzufügen. Dabei ist CVS so freundlich und macht uns entsprechende
Markierungen in die Textdatei, so dass wir die Konflikte schnell
finden können. Das sieht dann so aus (dazu wird die Datei mit einem
Editor geöffnet):

<<<<<<< cron
Linux bietet ehtliche Programme für das Automatisieren von
Aufgaben. Ein Beispiel ist cron. Beim Booten sollte ein cron Daemon
gestartet werden, der im Normalbtrieb nciht beendet wird.
=======
Linux bietet etliche Programme für das Automatisieren von
Aufgaben. Ein Beispiel ist cron. Beim Booten wird ein cron Daemon
gestartet und im Normalbetrieb nicht beendet.
>>>>>>> 1.3
Cron ist für sich wiederholende Aufgaben zuständig, die
automatisch zu bestimmten Zeiten stattfinden sollen.

Hinter dem "<<<<<<< cron" kommt der Teil des Textes, der in unserer
lokalen Arbeitskopie ist.
"=======" ist eine Trenner zwischen den beiden Revisionen.
Vor dem ">>>>>>> 1.3" steht der Text aus der Revision 1.3 aus dem
CVS-Repository.
Nun wird durch geeignetes Löschen der Teile, die falsch sind oder
durch Umschreiben des Textes der Konflikt gelöst. Dabei sind auch die
speziellen Markierungen vom CVS (<<< === >>>) zu löschen! Speichern und
Editor schließen und nun können wir die Datei "commiten":

user$ cvs ci -m "inhaltliche Aenderung" cron

Und siehe da, jetzt haben wir eine "konfliktfreie" Revision 1.4 .

Das Entstehen solcher Konflikte kann ganz leicht verhindert werden!
Es wird einfach, bevor der Text überhaupt bearbeitet wird, ein
"cvs update" gemacht und damit immer die aktuellste Version vom
CVS-Repository geholt. Also immer den Zyklus machen, so wie es in
der Zusammenfassung steht!



7.2 Einchecken fremder Texte

Dieser Spezialfall ist für all diejenige gedacht, die im Auftrag
anderer Autoren Texte ins CVS einchecken.

Wenn man solche Arbeiten übernimmt, dann sollte man im Umgang mit dem
CVS schon vertraut sein. Das Einchecken läuft genauso ab, wie bei
eigenen Texten. Der Spezialfall tritt ein, wenn uns der Autor
Änderungen zu seinem Text schickt, die man wieder einchecken
soll. Damit klar wird, was jetzt überhaupt gemeint ist, ein Beispiel.

Ich erhalte von einem Autor einen Text (wir nehmen mal an, der kennt
CVS überhaupt nicht). Diesen checke ich ein und der Text erhält die
Revision 1.1 . Dieser Text wird zur QA1 freigegeben und ein QA-ler
beseitigt einige kleine Rechtschreibfehler und andere Kleinigkeiten
und commitet diesen Text und er wird damit zu Revision 1.2 . Einige
Zeit später schickt der Autor mir eine verbesserte und erweiterte
Version seines Textes mit der Bitte zum Einchecken. Kein Problem!

Ich mache also cvs update, sehe, dass es die neue Revision 1.2 gibt,
deren Änderungen ich ja jetzt mit update geholt habe. Nun ist der
geänderte Text des Autors sehr umfangreich, also nehme ich ihn einfach
und kopiere in meinem Editor den neuen Text über den alten Text, mache
ein commit und freue mich, das die Revision 1.3 entstanden ist. Also
alles scheint bestens zu sein.

Dem aufmerksamen "CVS-Anwender" wird jetzt wohl ein etwas ungutes
Gefühl beschlichen haben. Ist das wirklich so richtig?

Was habe ich nun gemacht? Ich habe den erweiterten Originaltext des
Autors mit all den kleinen Fehlern genommen und über die Revision 1.2
"gebügelt". Das heißt, das alle Änderungen von der QA1 wieder weg
sind, also scheinbar rückgängig gemacht wurden, weil ich ja quasi einen
auf dem ursprünglich Originaltext (Revision 1.1) beruhenden Text
genommen habe und erneut komplett eingecheckt habe. Die
Wahrscheinlichkeit, das der Autor in dem geänderten Text all seine
kleinen Fehler selbst schon korrigiert hat, ist ziemlich gering. 

Auch der QA-ler beginnt jetzt an sich zu zweifeln, weil in der
Revision 1.3 all  die Fehler, die er schon korrigiert hatte, plötzlich
wieder da sind, sofern die QA1 noch nicht abgeschlossen wurde. Übler
wird es, wenn die QA1 schon abgeschlossen wurde und der Text als
scheinbar richtig sogar den Weg ins Tutorial findet.

Wie wäre es richtig? Nun man müsste die Revision 1.2 hernehmen und
alle Änderungen von dem erweiterten Originaltext MANUELL
einpflegen. Das wird aber bei umfangreichen Änderungen dann schnell
eine sehr aufwändige und auch sehr stupide Arbeit. 

Aber CVS ist ja eine (wie oben schon gesagt) geniale Sache und es gibt
natürlich einen eleganteren Weg, das Problem zu lösen. Es ist dabei
EXTREM wichtig zu wissen, auf was für eine Revision der geänderte
bzw. erweiterte Text des Autors (der uns den Text zugeschickt hat)
beruht. Also bitte vorher immer mit dem Autor abklären, auf welcher
Revision er das geschrieben bzw. verändert hat!

Gehen wir nochmal zu unserem Beispiel zurück, an dem Punkt wo wir den
erweiterten Text vom Autoren erhalten haben. Es ist der Text, den ich
als Revision 1.1 eingescheckt habe, bloß abgeändert bzw. erweitert. In
meiner Arbeitskopie ist aber schon die 1.2 . Ich kann aber dem CVS
jetzt sagen, dass ich in meine Arbeitskopie die Revision 1.1 (auf dem
die geänderte Version ja beruht) zurück haben möchte. Der Befehl dazu
lautet:

user$ cvs update -r 1.1 <text>

Jetzt befindet sich die ursprüngliche Revision in unserer
Arbeitskopie. Es kann hier natürlich eine ganz andere Revisionsnummer
stehen, z.B. 1.4 oder 1.38 . Wichtig ist hier zu wissen, in welcher
Revision der Autor die Änderungen gemacht hat. Das sieht man
normalerweise im Dokumentenheader. U.a. ist es darum so wichtig,
diesen Header in jeder Textdatei einzufügen!

Ich öffne die Datei mit einem Editor, kopiere den
geänderten Text über den Ursprungtext, speichern und schließe den
Editor wieder.

Nun möchte ich den Text ins CVS einchecken. CVS ist clever und  würde
natürlich sofort meckern, weil es ja schon eine Revision 1.2 im CVS
gibt. Hier gibt es einen ganz einfachen "Trick". Mit dem speziellen
Befehl:

user$ cvs update -A <text> 

wird unsere abgeänderte lokale Kopie mit der aktuellen Revision 1.2 im
CVS upgedatet und alle Änderungen dabei übernommen. Achtung, hier ist
die Wahrscheinlichkeit von Konflikten (die dann noch manuell aufgelöst
werden müssen) schon etwas höher! Das Clevere aber an der Sache ist,
das ich mit ZWEI CVS-Befehlen sowohl die Änderungen des Autors, als
auch die Änderungen von der QA1 in meine lokale Arbeitskopie eingefügt
habe. Cool, oder? Wenn die Konflikte beseitigt sind, kann ich diese
dann ins CVS einchecken und erhalte die Revision 1.3, die genau so
ist, wie wir sie haben wollen. :)

user$ cvs ci -m "Text vom Autor erweitert" <text>

So und nun das ganze nochmal als kurze Zusammenfassung:

user$ cd /<Pfad/<text>/ (das Verzeichnis in der lokalen Arbeitskopie!)
user$ cvs up -r 1.1 <text>
user$ cvs edit <text>
user$ $EDITOR <text>
  (speichern und evetl. schließen)
user$ cvs up -A <text>
  (eventuelle Konflikte beheben)
user$ cvs ci -m "bla bla bla" <text>

Erledigt!



--------------------------------------------------------
Autoren: Andreas Kalbitz
	 Jörg Meinhold
