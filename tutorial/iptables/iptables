<?xml version="1.0" encoding="ISO-8859-1"?>

<chapter>
 <title>IP-Tables</title>

 <author>
  <name>Gabriel Welsche</name>
  <mailto>gabriel.welsche@web.de</mailto>
 </author>

 <layout>
  <name>Matthias Hagedorn</name>
  <mailto>matthias.hagedorn@selflinux.org</mailto>
 </layout>

 <license>
    GFDL
 </license>

 <index>iptables</index>

 <split>
  <section>
   <heading>
Einleitung
   </heading>

   <textblock>
Dieses Kapitel beschäftigt sich vorrangig mit Paketfiltern.
Obwohl ein knapper Einstieg gegeben wird, ist es sinnvoll,
wenn detaillierte Kenntnisse zum Thema <strong>Netzwerke</strong>
(Topologien, Routing, QoS,
<ref chapter="nat">Nat</ref>, Ports) als
auch Grundlagen des
<ref chapter="kernel">Kernels</ref> vorhanden
sind.
   </textblock>
  </section>

  <section>
   <heading>
Grundlegende Begriffe
   </heading>

   <textblock>
Um Doppelungen zu vermeiden, soll an dieser Stelle auf
zwei wesentliche Selflinux Kapitel hingewiesen werden,
welche die grundlegenden Begriffe erläutern:
   </textblock>

   <textblock>
<ref chapter="osi">OSI-Referenzmodell</ref>
   </textblock>

   <textblock>
<ref chapter="tcpip">TCP/IP</ref>
(TCP/IP-Schichtenmodell, Adressierung,
Protokolle TCP/UDP/ICMP/IP/ARP, Ports )
   </textblock>
  </section>

  <section>
   <heading>
Grundlegendes zu Paketfiltern
   </heading>

   <textblock>
Die Aufgaben und der Zweck eines Paketfilters wurden bereits
im Kapitel <ref chapter="grundlagen_sicherheit">Überblick
zur Sicherheit von Linux-Systemen</ref>
gründlich vorgestellt. Ebenso wurde eindringlich davor gewarnt,
einen Paketfilter als einzige Maßnahme zur Sicherung des
heimischen Computers bzw. des kleinen Firmennetzwerks einzusetzen.
   </textblock>

   <textblock>
Was ist nun ein Paketfilter und wie arbeitet dieser?
   </textblock>

   <textblock>
Bei paketorientierten Netzwerkprotokollen (z.B. ip, tcp, udp)
werden die Daten in Pakete verpackt und ein Header (Paketkopf)
vorangestellt.
   </textblock>

   <image height="200">
    <filename>
pakete.png
    </filename>
   </image>

   <textblock>
Paketfilter werten den Paketkopf (Header) aus und entscheiden
anhand dessen über das weitere Schicksal des
ganzen Paketes. Entweder wird das Paket verworfen (Drop),
das bedeutet, es wird einfach gelöscht, oder es wird akzeptiert
(ACCEPT), das heißt es passiert den Filter, oder es wird
etwas Komplizierteres gemacht, auf das ich später eingehen werde.
   </textblock>

   <image height="200">
    <filename>
ip-filter.png
    </filename>
   </image>

   <textblock>
Bei Linux ist ein Paketfilter im Kernel integriert (einkompiliert
oder als eingebundenes Modul). Mit Hilfe eines Programms (z.B.
<command>ipchains</command> für Kernel 2.2 oder <command>iptables</command> für Kernel 2.4/2.6) kann man
mit dem Filter kommunizieren. Dies beinhaltet unter anderem
das Aufstellen von Regeln, mit denen man definieren kann, welche
Pakete den Filter unter welcher Voraussetzung passieren dürfen.
   </textblock>
  </section>
 </split>

 <split>
  <section>
   <heading>
Was leistet ein Paketfilter?
   </heading>

   <section>
    <heading>
Kontrolle und Sicherheit
    </heading>

    <textblock>
Ein Paketfilter kann anhand des Pakettyps, anhand des
Herkunftsortes und anhand weiterer Eigenschaften des
Paketes bestimmte Kommunikationsarten erlauben oder
verbieten. Die Entscheidung basiert nicht auf dem
Inhalt des Paketes!
    </textblock>

    <textblock>
Ein Beispiel:<br/>
Die meisten Internetbenutzer wollen keine eigenen
Dienste vom heimischen PC aus anbieten. Es sollte also
niemandem aus dem Internet heraus erlaubt sein, eine
Verbindung zu dem privaten PC aufzubauen.
    </textblock>

    <textblock>
Zweites Beispiel:<br/>
Ein mittelständiges Unternehmen unterhält eine
eigene kleine Entwicklungsabteilung, deren
Erkenntnisse einer gewissen Geheimhaltungsstufe unterliegen:<br/>
Die Dokumente sollen nicht in die Hände der Konkurrenz fallen.
Das schwierige an der Sache ist, dass die Mitarbeiter für
ihre Arbeit einen WWW-Zugang benötigen. Ein Paketfilter hat
die Aufgabe den Datenaustausch von geheimen Dokumenten
zu erschweren. Wie - dies wird später erläutert.
    </textblock>

    <textblock>
Paketfilter können auch sehr differenziert entscheiden,
wer etwas darf und wer nicht.
    </textblock>
   </section>

   <section>
    <heading>
Beobachtung des Netzverkehres
    </heading>

    <textblock>
Paketfilter können auch den Datenverkehr überwachen und bei
Unregelmäßigkeiten eine Meldung erzeugen.
    </textblock>

    <textblock>
Ein Beispiel:<br/>
Nachts drei Uhr wird eine Internetverbindung aufgebaut.
Da um diese Zeit keiner in der Firma sein dürfte,
liegt die Vermutung nahe, es könnte ein Virus oder ein
Trojanisches Pferd ungewollte Dinge verrichten.
    </textblock>
   </section>

   <section>
    <heading>
Paketumleitung und Paketmanipulation
    </heading>

    <textblock>
Paketfilter können den Datenverkehr auf einen Proxy
umleiten, der auf Applikationsebene Entscheidungen
fällt. Damit lassen sich beispielsweise transparente
Virenscanner oder Kindersicherungen einrichten, und zwar
ohne dass die Netzwerkteilnehmer (also z.B. Schüler)
etwas davon merken.
    </textblock>

    <textblock>
Ein weiteres Einsatzgebiet stellt
<ref chapter="nat">NAT</ref> bzw.
IP-Masquerading dar. Damit lassen sich beispielsweise
viele Rechner über eine einzige <ref chapter="isdn">ISDN</ref>-
oder <ref chapter="adsl">DSL</ref>-Verbindung
mit dem Internet verbinden.
    </textblock>
   </section>

   <section>
    <heading>
Attackenbekämpfung
    </heading>

    <textblock>
Prinzipiell werden zwei Angriffstypen unterschieden:
    </textblock>

    <textblock>
Zum einen sind dies Attacken mit dem Ziel, in ein System
einzudringen, um dann Daten zu stehlen oder es als
Ausgangspunkt für weitere Angriffe zu nutzen. Dazu nutzen
die Angreifer Schwachstellen im Betriebssystem oder in
Anwendungsprogrammen (Client- und Serversoftware).
    </textblock>

    <textblock>
Zum anderen besteht das Angriffsziel darin, einen Rechner
lahm zu legen oder diesen vom Netzwerk zu trennen. Solche
Attacken bezeichnet man auch als DOS- bzw. ihre
Weiterentwicklung als DDOS-Attacken
(Distributed Denial of Service Attack).
    </textblock>

    <textblock>
Paketfilter können einige Angriffsvarianten vereiteln, so
zum Beispiel TCP-SYN-Flooding-Attacken oder
Large Packet Attacks (Ping of Death). Man kann auch das
Scannen des Netzwerkes verhindern. Mit dieser Technik
versuchen Angreifer, so viel wie möglich Informationen
über das System zu erhalten. Ebenfalls erschweren kann man
IP-Spoofing Attacken durch das Aufstellen genereller
Filterregeln (z.B. Pakete mit interner Absenderadresse
dürfen nicht von Außen nach Innen gelangen.)
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Prinzipielle Funktionsweise unter Linux
   </heading>

   <textblock>
Folgende Erklärungen beziehen sich auf 2.4er/2.6er Kernel,
bei früheren Versionen gab es andere Konzepte
(<command>ipchains</command>, <command>ipfw</command>).
   </textblock>

   <textblock>
Zuerst benötigt man einen Kernel mit der Netfilter-Infrastruktur,
das bedeutet, man braucht das <command>iptables</command> Kernelmodul und
ein <command>CONFIG_NETFILTER=Y</command> in der Kernelkonfiguration.
   </textblock>

   <textblock>
Das Programm <command>iptables</command> kommuniziert mit dem
<ref chapter="kernel">Linux-Kernel</ref>
und weist diesen an, Pakete nach bestimmten Regeln zu
filtern. <command>iptables</command> übernimmt also unter anderem das
Einfügen, Löschen und Manipulieren von Regeln in die
Filtertabellen des Kernels sowie das Setzen der
Filterpolitik. Bei einem Neustart des Computers gehen
alle angelegten Regeln verloren, deshalb ist ein
automatisches Setzen von Regeln sinnvoll. Mit den Tools
<command>iptables-save</command> und <command>iptables-restore</command> können die Regeln
gesichert und wiederhergestellt werden. Beim Bootvorgang
übernimmt dies ein Init-Script.
   </textblock>

   <textblock>
Im 2.4er/2.6er Linuxkernel werden Listen von Regeln
(Firewall-Ketten) in einer Filtertabelle verwaltet.
Standardmäßig sind INPUT, OUTPUT und FORWARD-Ketten vorhanden.
Der genaue Weg der Pakete wird später beschrieben,
das folgende Diagramm gibt schon mal einen ersten Überblick:
   </textblock>

   <image height="150">
    <filename>
filter-tabellen.png
    </filename>
   </image>

   <textblock>
Jede Kette (INPUT, OUTPUT, FORWARD) entscheidet anhand von
Regeln, ob ein Paket gelöscht oder akzeptiert wird. Wird es
akzeptiert, dann reist es weiter durch das Diagramm bis es
letztendlich den Rechner über den Ausgang verlassen kann.
   </textblock>

   <textblock>
Jede Kette beinhaltet eine Checkliste von Regeln, die ungefähr
so aussehen:
   </textblock>

   <textblock>
WENN (Filteroption)
DANN Aktion (Löschen, Akzeptieren, ... des Paketes)
   </textblock>

   <textblock>
Die Regeln werden nacheinander solange durchlaufen, bis
eine Regel auf das eingegangene Paket zutrifft.
   </textblock>

   <image height="200">
    <filename>
regeln.png
    </filename>
   </image>

   <textblock>
Ist das Ende der Regelkette erreicht (keine Regel traf zu)
entscheidet die <strong>*Policy*</strong> der Kette (zu deutsch:
Politik, Taktik, Vorgehensweise) darüber, was mit dem Paket
zu tun ist. In einem sicherheitsbewussten System werden
alle Pakete verworfen, für die keine Regel zutrifft.
(prohibitive Sicherheitspolitik)
   </textblock>

   <textblock>
Nun soll noch einmal der Weg der Pakete
durch den Paketfilter ganz genau betrachtet werden:
   </textblock>

   <textblock>
Nach Eingang eines Paketes an einer Netzwerkschnittstelle (a)
wird dessen Zieladresse ausgewertet (Routing). Ein Paket mit
Zieladresse dieses Rechners (b) wird anschließend durch die
INPUT-Kette geprüft. Diese kann das Paket entweder verwerfen
oder für die weitere Verarbeitung durchlassen. Letztendlich
kann eine Anwendung die empfangenen Daten dem Nutzer zur
Verfügung stellen (anzeigen, abspeichern, ...).
   </textblock>

   <textblock>
Ein lokaler Prozess (z.B. Mozilla) könnte ein neues Paket
(Anforderung einer Webseite) erzeugen und dieses ins
Netzwerk versenden (d). Die OUTPUT-Kette leitet nach einer
erfolgreichen Prüfung das Paket weiter zur gewünschten
Netzwerkschnittstelle (z.B. <command>eth0</command> / <command>ippp0</command>).
   </textblock>

   <textblock>
Kommunikationsserver oder Router verbinden meist ein inneres
(privates) Netzwerk mit einem äußeren (öffentlichen) Netz,
zum Beispiel dem Internet. Dafür wird die Paketweiterleitung
von einer Netzwerkschnittstelle (Eingang) zu einer anderen
(Ausgang) benötigt. Die FORWARD-Kette prüft in diesem
Fall nun die Pakete, die vom inneren ins äußere Netz oder
umgekehrt (f), (g) übertragen werden sollen.
   </textblock>

   <textblock>
Es sei an dieser Stelle darauf hingewiesen, dass es neben der
Filtertabelle (INPUT-, OUTPUT-, FORWARD-Kette) auch noch eine
NAT-Tabelle (PREROUTING-, POSTROUTING-, OUTPUT-Kette) für die
sogenannte <strong>Network Address Translation</strong> existiert, welches
<ref iref="Kombinieren von NAT und Paketfilter">später</ref>
beschrieben ist. Ebenso gibt es auch noch eine MANGLE Tabelle
mit PREROUTING- und OUTPUT-Kette zur
<ref iref="Explizite Erweiterungen">Paketmanipulation</ref>
   </textblock>
  </section>
 </split>

 <split>
  <section>
   <heading>
Praktischer Einstieg in iptables
   </heading>

   <section>
    <heading>
Grundlegendes zu iptables
    </heading>

    <textblock>
Wie bereits erwähnt sind nach dem Booten keine Regeln
in einer der eingebauten Ketten (INPUT, OUTPUT, FORWARD)
vorhanden, und die Policy (Sicherheitspolitik) steht
standardmäßig auf <strong>ACCEPT</strong>.
    </textblock>

    <textblock>
(Achtung: manche Distributionen haben iptables-Befehle
in den Init-Skripten)
    </textblock>

    <textblock>
Die Standard-Policy kann geändert werden, wenn das
<command>iptables_filter</command> Kernelmodul mit einer entsprechende Option
gestartet wurde (z.B. für FORWARD-Kette: <command>forward=0</command>).
    </textblock>

    <textblock>
Das Programm <command>iptables</command> bietet folgende Optionen
zur Verwaltung von Filterregelketten:
    </textblock>

    <ul>
     <li>
Eine neue Kette erstellen (<command>-N</command>).
     </li>
     <li>
Eine leere Kette löschen (<command>-X</command>). (geht nicht mit INPUT, OUTPUT und FORWARD)
     </li>
     <li>
Die Policy für eine eingebaute Kette ändern (<command>-P</command>).
     </li>
     <li>
Die Regeln einer Kette auflisten (<command>-L</command>).
     </li>
     <li>
Die Regeln aus einer Kette entfernen (flush) (<command>-F</command>).
     </li>
     <li>
Paket und Bytezähler aller Regeln einer Kette auf Null stellen (<command>-Z</command>).
     </li>
    </ul>

    <textblock>
Verwaltung der Regeln in einer Kette:
    </textblock>

    <ul>
     <li>
Eine neue Regel an eine Kette anhängen (<command>-A</command>).
     </li>
     <li>
Eine neue Regel an eine bestimmte Position in der Kette einfügen (<command>-I</command>).
     </li>
     <li>
Eine Regel an bestimmter Position in der Kette ersetzen (<command>-R</command>).
     </li>
     <li>
Eine Regel an einer bestimmten Position in der Kette löschen (<command>-D</command>).
     </li>
     <li>
Die erste passende Regel in einer Kette löschen (<command>-D</command>).
     </li>
    </ul>
   </section>

   <section>
    <heading>
Operationen auf einer einzelnen Regel (Regeln manipulieren)
    </heading>

    <textblock>
Mit den Befehlen zum Anhängen (<command>-A</command>) oder Löschen (<command>-D</command>) einer Regel
stehen die grundlegenden Kommandos zur Verfügung. Weitere
Befehle zum Einfügen (<command>-I</command>) und zum Ersetzen (<command>-R</command>) sind einfache
Erweiterungen, die das Leben manchmal erleichtern und die
dennoch kaum gebraucht werden.
    </textblock>

    <textblock>
Jede Regel definiert eine Menge von Bedingungen, die ein
eintreffendes Paket erfüllen muss, und ein Ziel (target),
welches das weitere Schicksal des Paketes bestimmt.
    </textblock>

    <textblock>
Zum Beispiel:
    </textblock>

    <textblock>
Es sollen alle ICMP-Pakete (z.B. von <command>ping</command> generiert)
verworfen werden, die vom lokalen Rechner 127.0.0.1
stammen:
    </textblock>

    <textblock>
Bedingungen: Protokoll ICMP und Quelladresse 127.0.0.1<br/>
Ziel: ist Verwerfen (DROP).
    </textblock>

    <textblock>
Ping sendet einen <command>echo request</command> (ICMP Typ 8) und
alle kooperierenden Hosts antworten darauf
verbindlich mit einem <command>echo reply</command> (ICMP Typ 0).
    </textblock>

    <textblock>
ohne Filter
    </textblock>

    <shell>
     <root>
ping -c 1 127.0.0.1
     </root>
     <output>
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.2 ms

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.2/0.2/0.2 ms
     </output>
    </shell>

    <textblock>
Jetzt wird die INPUT-Kette um eine Regel erweitert (<command>-A</command>), so dass
Pakete, die von 127.0.0.1 (<command>-s 127.0.0.1</command>) kommen und das
Protokoll ICMP (<command>-p icmp</command>) verwenden, zu verwerfen
sind (<command>-j DROP</command>):
    </textblock>

    <shell>
     <root>
iptables -A INPUT -s 127.0.0.1 -p icmp -j DROP
     </root>
    </shell>

    <textblock>
Test
    </textblock>

    <shell>
     <root>
ping -c 1 127.0.0.1
     </root>
     <output>
PING 127.0.0.1 (127.0.0.1): 56 data bytes

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss
     </output>
    </shell>

    <textblock>
Die Regel scheint zu funktionieren. Doch wie löscht man nun
diese Regel wieder? Wenn die Position der Regel in der Kette
bekannt ist (in diesem Fall gibt es nur die eine
Regel, deshalb Position 1), kann man diese Position
als Parameter verwenden:
    </textblock>

    <shell>
     <root>
iptables -D INPUT 1
     </root>
    </shell>

    <textblock>
Sollte die Position jedoch nicht bekannt sein, so muss man die
Regel nochmals vollständig angeben, also genau wie beim Anhängen
der Regel, nur das anstelle des Befehls <command>-A</command>
der Befehl <command>-D</command> steht:
    </textblock>

    <shell>
     <root>
iptables -D INPUT -s 127.0.0.1 -p icmp -j DROP
     </root>
    </shell>

    <textblock>
Wenn die Regel mehrfach in Regelkette aufgenommen wurde, so wird
nur die erste gelöscht. Man sollte also IMMER nach dem Entfernen
nochmals alles kontrollieren! (In diesem Falle also mit <command>ping</command>)
    </textblock>
   </section>

   <section>
    <heading>
Schnelle Lösung ohne viele Worte
    </heading>

    <textblock>
Viele Leser nutzen nur Modem/ISDN oder DSL-Verbindung zum
Internet und die einzige Sorge ist, dass niemand vom Internet
in ihren Computer oder privates Netzwerk kommen kann.
Die folgende Anleitung funktioniert mit einem 2.4er/2.6er Kernel.
    </textblock>

    <textblock>
1) Kernelmodule einfügen, wenn diese noch nicht einkompiliert
wurden (notwendig wegen Verbindungsverfolgung)
    </textblock>

    <shell>
     <root>
modprobe ip_conntrack
     </root>
     <root>
modprobe ip_conntrack_ftp
     </root>
    </shell>

    <textblock>
2) Befehle ausführen (am besten ein SysV-Initskript
erstellen, welches beim Hochfahren des Rechners
automatisch gestartet wird)
    </textblock>

    <file>
     <title>
SysV-Initskript
     </title>
     <content>
# alle Verbindung blocken, es sei denn, sie kommen von innen

iptables -N block
iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A block -m state --state NEW -i ! ppp0 -j ACCEPT
iptables -A block -j DROP

# Von INPUT und FORWARD Ketten zu dieser Kette springen

iptables -A INPUT -j block
iptables -A FORWARD -j block
     </content>
    </file>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Filterbestimmungen (Filteroptionen)
   </heading>

   <section>
    <heading>
Grundlegende Filteroptionen
    </heading>

    <textblock>
Wie bereits erwähnt, beinhaltet jede Kette
(INPUT, OUTPUT, FORWARD) eine Checkliste von
Regeln, die folgendermaßen aussehen:
    </textblock>

    <textblock>
WENN (Filteroption)
DANN Aktion (Löschen, Akzeptieren, ... des Paketes)
    </textblock>

    <textblock>
Im letzten Abschnitt wurden bereits zwei
Filteroptionen (<command>-s</command> und <command>-p</command>) für die INPUT-Kette
angewendet:
    </textblock>

    <textblock>
Verwerfe alle ankommenden ICMP Pakete von localhost
    </textblock>

    <shell>
     <root>
iptables -A INPUT -s 127.0.0.1 -p icmp -j DROP
     </root>
    </shell>

    <textblock>
Mit <command>-p</command> wurde das Protokoll ICMP bestimmt, die
<command>-s</command> Option legte die Quelladresse der Pakete fest.
    </textblock>

    <textblock>
Die folgenden Filteroptionen können angegeben werden:
    </textblock>

    <ul>
     <li>
Quell- und Zieladresse festlegen:<br/>
<command>-s</command>, <command>--source</command> oder <command>-src</command>  - Quelladresse<br/>
<command>-d</command>, <command>--destination</command> oder <command>--dst</command> - Zieladresse<br/>
<br/>
Quell- und Zieladressen können folgendermaßen angegeben werden:
      <ol type="a">
       <li>
Namen  (z.B. "localhost" oder "www.mydomain.com")
       </li>
       <li>
IP-Adresse (Bsp. "127.0.0.1")
       </li>
       <li>
Subnetz ("192.168.1.0/24" oder "192.168.1.0/255.255.255.0"
sind alle IP-Adressen von 192.168.1.0 bis 192.168.1.255)<br/>
Bsp: <br/><br/>
<command>iptables -A INPUT -s 192.168.1.0/24 -j DROP</command><br/>
       </li>
      </ol>
     </li>
     <li>
Protokoll<br/>
<command>-p</command> oder <command>--protocol</command>. Die Angabe des Protokolls erfolgt
durch
      <ol type="a">
       <li>
Protokollnamen z.B. "TCP", "UDP" oder "ICMP"
(Gross- und Kleinschreibung ist egal, es
funktioniert beides)
oder
       </li>
       <li>
die IP-Protokollnummer <br/>
Bsp:<br/><br/>
<command>iptables -A INPUT -s 192.168.1.0/24 -p ! icmp -j DROP</command><br/>
       </li>
      </ol>
     </li>
     <li>
Netzwerkschnittstelle <br/>
<command>-i</command> oder <command>--in-interface</command>   Eingangsschnittstelle <br/>
<command>-o</command> oder <command>--out-interface</command>  Ausgangsschnittstelle<br/><br/>

Mit dem <command>ifconfig</command> Kommando können alle aktiven
Schnittstellen angezeigt werden. <br/><br/>

Die INPUT-Kette stellt  keine Output-Schnittstelle zur
Verfügung (siehe Bild oben), in dieser Kette ist die
<command>-o</command> Option also zwecklos. Analog dazu hat die
OUTPUT-Kette keine INPUT-Schnittstelle, also werden Regeln
mit  <command>-i</command> Option niemals zutreffen und sind deshalb ebenso
obsolet. Nur Pakete, welche die FORWARD-Kette durchwandern,
können über INPUT- und OUTPUT-Schnittstelle gefiltert
werden.<br/><br/>

Es können auch Schnittstellen zuordnet werden, die
beim Anlegen der Regel noch gar nicht existieren
(Dialup-PPP Schnittstellen)
Kein Paket kann bis zur Aktivierung der Schnittstelle
die Regel erfüllen, sie stört somit also keinesfalls.<br/><br/>

Schnittstellennamen, die mit einem <command>+</command> enden, bezeichnen alle
Schnittstellen, die mit dieser Zeichenkette beginnen,
egal ob diese in dem Moment existieren oder nicht.<br/>
Beispiel: Eine Regel mit der folgenden Option trifft auf alle
PPP-Schnittstellen zu:  <command>-i ppp+</command><br/><br/>
     </li>
     <li>
Inversion (Verneinung)
Jede Option ist invertierbar durch Angabe eines <command>!</command> hinter
der jeweiligen Option:<br/>
Bsp:<br/><br/>

<command>iptables -A INPUT -s ! 127.0.0.1 -p icmp -j DROP</command><br/><br/>

Die Regel gilt für alle ICMP-Pakete, die NICHT vom
lokalen Rechner kommen.
     </li>
    </ul>
   </section>

   <section>
    <heading>
Fragmente filtern
    </heading>

    <textblock>
Zu große Pakete werden in Fragmente aufgeteilt und in
mehreren Paketen weiterverschickt. Die Gegenstelle setzt
diese Fragmente wieder zusammen, um das gesamte Paket
zu rekonstruieren.
    </textblock>

    <textblock>
Bei <strong>connection tracking</strong> oder NAT werden alle Fragmente
wieder miteinander verschmolzen, bevor sie den Paketfilter
erreichen, alles ist also wie gehabt.
    </textblock>

    <textblock>
Ansonsten hat unseren Paketfilter nun folgendes Problem: das
erste Fragment enthält die kompletten Header-Felder (IP + TCP,
UDP und ICMP), die nachfolgenden Fragmente besitzen nur
Teilstücke der Header (IP ohne die zusätzlichen
Protokoll-Felder) Daher ist es nicht möglich, in
nachfolgenden Fragmenten nach Protokoll-Headern zu suchen
(wie es zum Beispiel bei TCP, UDP und ICMP Erweiterungen
getan wird).
    </textblock>

    <textblock>
Anders formuliert: Das erste Fragment kann wie jedes andere
Paket gefiltert werden, bei dem zweiten und alle weiteren
Fragmenten greifen die bisher bekannten Regeln nicht.
So wird beispielsweise <command>-p TCP --sport www</command>
(die einen Quellport von www filtert) ausschließlich auf
das erste Fragment zutreffen.
    </textblock>

    <textblock>
Die Lösung des Problems besteht im Hinzufügen einer Regel
für Fragmente mittels <command>-f</command> (<command>--fragment</command>) Option.
    </textblock>

    <textblock>
Normalerweise gilt es als sicher, wenn man zweite und
weitere Fragmente akzeptiert und nur das erste Fragment
herausgefiltert wird. Trotzdem: Werden Fragmente
akzeptiert, dann können durch das Ausnutzen von
Software-Bugs Rechner zum Absturz gebracht werden.
(DOS Attacke)
    </textblock>

    <textblock>
Anmerkung:<br/>
Missgeformte Pakete (die z.B. zu klein sind,
um Ports oder ICMP Code oder Type zu lesen) werden
verworfen. TCP-Fragmente starten also bei Position 8.
    </textblock>

    <textblock>
Die folgende Regel verwirft jegliche Fragmente,
die an 192.168.1.1 gehen:
    </textblock>

    <shell>
     <root>
iptables -A OUTPUT -f -d 192.168.1.1 -j DROP
     </root>
    </shell>
   </section>

   <section>
    <heading>
iptables MATCH-Erweiterungen
    </heading>

    <section>
     <heading>
Grundlegendes zu Erweiterungen
     </heading>

     <textblock>
Sowohl der <command>iptables</command> Kernel-Code als auch das iptables Tool
können erweitert werden. Viele dieser Erweiterungen sind für
eine sichere Firewall unumgänglich. Jeder kann Erweiterungen
entwickeln und diese anbieten.
     </textblock>

     <textblock>
Kernelerweiterungen residieren normalerweise im
Unterverzeichnis für Kernelmodule, z.B.
<path>/lib/modules/2.4.24/net</path> und werden bei Bedarf geladen. Wenn
im Kernel die Option <command>CONFIG_KMOD</command> gesetzt ist, dann erfolgt
das Laden vollautomatisch.
     </textblock>

     <textblock>
Erweiterungen für das Tool <command>iptables</command> sind Shared Libraries,
die gewöhnlich unter <path>/usr/local/lib/iptables</path> , unter
<path>/lib/iptables</path> oder bei manchen Distributionen auch unter
<path>/usr/lib/iptables</path> zu finden sind.
     </textblock>

     <textblock>
Wir betrachten hier erst einmal MATCH-Erweiterungen, es geht
also um eine Erweiterung der Filterbedingungen. Implizite
Erweiterungen (tcp, udp, icmp) werden mit der Option <command>-p</command>
geladen, explizite Erweiterungen mit der Option <command>-m</command>.
     </textblock>

     <textblock>
Die Hilfe für eine Erweiterung erhält man, wenn nach
der Option zum Laden der Erweiterung (<command>-p</command> oder <command>-m</command>)
ein <command>-h</command> oder <command>--help</command> angegeben wird.
     </textblock>

     <textblock>
Zum Beispiel:
     </textblock>

     <shell>
      <root>
iptables -p udp --help
      </root>
     </shell>
    </section>

    <section>
     <heading>
TCP Erweiterungen
     </heading>

     <textblock>
Manchmal sollen bestimmte Dienste innerhalb des Netzes
von außen (bzw. anderen Netzbereichen) nicht erreichbar
sein. Viele Dienste benutzen das verbindungsorientierte
TCP-Protokoll. Der Aufbau dieser TCP-Verbindungen erfolgt
nach dem Three-Way-Handshake Protokoll, hier ist
nochmals eine Kurzzusammenfassung:
     </textblock>

     <textblock>
Der Server wurde mit <strong>S</strong> bezeichnet, der Client mit <strong>C</strong>.
     </textblock>

     <ol>
      <li>
(C) --> [SYN] --> (S)<br/>
Der Client sendet ein Synchronisationspaket (Synchronize)
und erklärt damit, dass er eine Verbindung aufbauen möchte.
      </li>
      <li>
(C) &lt;-- [SYN/ACK] &lt;--(S)<br/>
Der Server akzeptiert den Verbindungswunsch und sendet ein
SYN/ACK Paket (Synchronize/Acknowledgement) zurück.
      </li>
      <li>
(C) --> [ACK] --> (S)<br/>
Der Client wiederum bestätigt, dass die Verbindung nun
aufgebaut ist/wird mit einem ACK-Paket (Empfangsbestätigung)
      </li>
     </ol>

     <textblock>
[Ein SYN-Paket ist ein TCP-Paket, bei dem ausschließlich
das SYN-Flag gesetzt ist.]
     </textblock>

     <textblock>
Alle weiteren TCP-Pakete dieser Verbindung haben übrigens
auch ein gesetztes ACK-Flag.
     </textblock>

     <textblock>
Wenn man nur die [SYN] Pakete eines Rechners blockt, können
Verbindungsversuche von diesem unterbunden werden.
Die Filterung dieser Pakete erfolgt durch
die TCP Erweiterungen, die mit <command>-p tcp</command> geladen werden.
Inversionen  (Verneinungen) sind durch ein <command>!</command>
hinter der Option möglich.
     </textblock>

     <textblock>
Es gibt folgende Optionen:
     </textblock>

     <textblock>
<command>--tcp-flags</command>
     </textblock>

     <quotation>
gefolgt von zwei Zeichenketten. Die erste Zeichenkette
enthält eine Liste von Flags, die untersucht werden.
Die zweite Zeichenkette sind die Flags, die gesetzt
sein sollen. Mögliche Flags sind: <br/>
<strong>SYN, ACK, FIN, RST, URG, PSH</strong> bzw. <strong>ALL</strong> für alle und
<strong>NONE</strong> für keine Flags.
     </quotation>

     <textblock>
<command>--syn</command>
     </textblock>

     <quotation>
entspricht <command>--tcp-flags SYN,RST,ACK SYN</command>.
     </quotation>

     <textblock>
<command>--source-port</command> oder <command>--sport</command>
     </textblock>

     <quotation>
Gefolgt von einem bzw. mehreren TCP-Ports.
Ports können durch Namen (<path>/etc/services</path>) oder Portnummer
angegeben werden. Auch ganze Bereiche sind möglich.
(z.B. 10000-11000)
     </quotation>

     <textblock>
<command>--destination-port</command> oder <command>--dport</command>
     </textblock>

     <quotation>
bedeutet Zielport
     </quotation>

     <textblock>
<command>--tcp-option</command>
     </textblock>

     <quotation>
Gefolgt von einer Nummer, welche die TCP-Option angibt.
TCP-Pakete ohne kompletten Header werden bei dem Versuch,
die TCP-Option zu bestimmen, automatisch verworfen.
     </quotation>

     <textblock>
Beispiel:
     </textblock>

     <shell>
      <root>
iptables -A INPUT -p TCP -s 192.168.1.0/24 --tcp-flags SYN,RST,ACK SYN -j DROP
      </root>
     </shell>
    </section>

    <section>
     <heading>
UDP Erweiterungen
     </heading>

     <textblock>
Diese Erweiterungen werden mit <command>-p udp</command> automatisch geladen.
Sie bieten die Optionen <command>--source-port</command> (<command>--sport</command>) und
<command>--destination-port</command> (<command>--dport</command>), wie sie bereits oben für
TCP detailliert beschrieben wurden.
     </textblock>
    </section>

    <section>
     <heading>
ICMP Erweiterungen
     </heading>

     <textblock>
Diese Erweiterungen werden mit <command>-p icmp</command> geladen und bieten
nur eine neue Option:
     </textblock>

     <textblock>
<command>--icmp-type</command>
     </textblock>

     <quotation>
Gefolgt vom ICMP-Typnamen (zum Beispiel 'host-unreachable'),
oder einer entsprechenden Nummer.<br/><br/>

Eine Liste verfügbarer ICMP Typnamen erhält man mit
der Option "-p icmp --help".
     </quotation>
    </section>

    <section>
     <heading>
Explizite Erweiterungen
     </heading>

     <textblock>
Die expliziten Erweiterungen im netfilter-Paket sind keine
Standarderweiterungen. Man muss dazu spezielle Kernelmodule
(z.B. <command>ipt_mac</command>, <command>ipt_limit</command>, <command>ipt_owner</command>) laden, eine
Auflistung der Module befindet sich im
<ref iref="Übersicht über die Standard-Module von IP-Tables">Anhang</ref>.
     </textblock>

     <textblock>
Die Erweiterung ruft man mit der Option <command>-m</command> auf.
     </textblock>

     <textblock>
<command>mac</command> (<command>-m mac</command> oder "<command>--match-mac</command>")
     </textblock>

     <quotation>
Dieses Modul wird verwendet, um die
MAC-Adressen einkommender Pakete zu filtern.
Hinter der Option <command>--mac-source</command> wird eine
Netzwerkadresse in durch Doppelpunkte
getrennter Hex-Notation angegeben.
(z.B. <command>-m mac --mac-source 00:60:08:91:CC:B7</command>).
     </quotation>

     <textblock>
<command>limit</command> (<command>-m limit</command> oder <command>--match-limit</command> )
     </textblock>

     <quotation>
Limit schränkt die Paketanzahl auf eine vorgegebene Rate
ein. Vorstellen kann man sich das System wie ein
Rückhaltebecken mit konstantem Abfluss. Damit das Speicherbecken
nicht überläuft, wird im Falle eines zu großem Stromes
ein anderer Weg eingeschlagen.
     </quotation>

     <image height="200">
      <filename>
limit.png
      </filename>
     </image>

     <textblock>
Unser Strom besteht nicht aus Wasser sondern aus Datenpaketen,
der <strong>normale</strong> Weg ins Rückhaltebecken bedeutet das Erfüllen
der Regelbedingung und mit dem alternativen Weg (Überlaufschutz)
ist das Nichterfüllen der Regel gemeint.
     </textblock>

     <textblock>
Das System kann mit zwei Parametern beschrieben werden:
     </textblock>

     <ul>
      <li>
Das Speichervolumen (Parameter "<command>--limit-burst</command>") beschreibt
die Anzahl der Maximaltreffer.
      </li>
      <li>
Die Abflussgeschwindigkeit ("<command>--limit</command>") legt die Anzahl
der maximalen Treffer pro Zeiteinheit fest.
Werden diese beiden optionalen Parameter nicht angegeben,
dann gelten die die Standardwerte (3 Treffer/Stunde und
Maximalgrenze von 5 Treffern).
     </li>
    </ul>

     <textblock>
Limit kann verwendet werden, um Pakete zu loggen:
     </textblock>

     <shell>
      <root>
iptables -A FORWARD -m limit -j LOG
      </root>
     </shell>

     <textblock>
Limit bietet Schutz vor "Syn-Flood-Attacken":
     </textblock>

     <shell>
      <root>
iptables -A FORWARD -p tcp --syn -m limit 1/s -j ACCEPT
      </root>
     </shell>

     <textblock>
Schutz vor "Ping of Death":
     </textblock>

     <shell>
      <root>
iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
      </root>
     </shell>

     <textblock>
Portscanner ausschalten:
     </textblock>

     <shell>
      <root>
iptables -A FORWARD -p tcp --tcp-flags ALL NONE -m limit --limit 1/h -j ACCEPT
      </root>
      <root>
iptables -A FORWARD -p tcp --tcp-flags ALL ALL -m limit --limit 1/h -j ACCEPT
      </root>
     </shell>

     <textblock>
<command>owner</command> (<command>-m owner</command>)
     </textblock>

     <quotation>
Diese Erweiterung filtert Charakteristika von Paketen und
bestimmt damit deren Herkunft (lokaler Prozess). Man darf
es nur in der Output-Kette benutzen:
     </quotation>

     <textblock>
<command>--uid-owner userid</command>
     </textblock>

     <quotation>
Das Paket wurde von einem Prozess mit der
angegebenen effektiven User ID generiert.
     </quotation>

     <textblock>
<command>--uid-owner groupid</command>
     </textblock>

     <quotation>
Das Paket wurde von einem Prozess mit der
angegebenen effektiven Gruppen ID generiert.
     </quotation>

     <textblock>
<command>--pid-owner processid</command>
     </textblock>

     <quotation>
Das Paket wurde von einem Prozess mit der
angegebenen effektiven Prozess ID generiert.
     </quotation>

     <textblock>
<command>--sid-owner processid</command>
     </textblock>

     <quotation>
Das Paket wurde von einem Prozess in der
angegebenen session group generiert.
     </quotation>

     <textblock>
<command>state</command> (<command>-m state</command> oder <command>--state</command>)
     </textblock>

     <quotation>
Mit dieser Erweiterung können durch die Option <command>--state</command>
Verbindungszustände von Paketen gefiltert werden.
Zustände sind:
     </quotation>

     <quotation>
<strong>NEW</strong>
     </quotation>

     <quotation>
Ein Paket, das eine neue Verbindung aufbaut, erfüllt
diese Regelbedingung.
     </quotation>

     <quotation>
<strong>ESTABLISHED</strong>
     </quotation>

     <quotation>
Trifft für Pakete zu, die zu einer bereits aufgebauten
Verbindung gehören
     </quotation>

     <quotation>
<strong>RELATED</strong>
     </quotation>

     <quotation>
Trifft für verwandte Pakete zu. Verwandt sind z.B.
ICMP Fehler einer Verbindung, oder (mit dem eingefügten
FTP-Modul) ein Paket, das eine FTP Datenverbindung aufbaut.
     </quotation>

     <quotation>
<strong>INVALID</strong>
     </quotation>

     <quotation>
Ein Paket, das nicht identifiziert werden konnte.
(Pakete sollten verworfen werden!)
     </quotation>

     <quotation>
Die Möglichkeiten, die diese Option bietet,
werden noch sehr detailliert im Kapitel
<ref iref="Verbindungsverfolgung (Connection Tracking)">Verbindungsverfolgung
(Connection Tracking)</ref> bespochen werden.
     </quotation>

     <textblock>
Beispiel:
     </textblock>

     <shell>
      <root>
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
      </root>
     </shell>

     <textblock>
<command>tos</command> (<command>-m</command> )
     </textblock>

     <textblock>
Die TOS-Bits (Table-Of-Service) sind Flags im IP-Header, die
eine Dienstgüte beschreiben. Im Einzelnen sind dies:
     </textblock>

     <table border="1">
      <pdf-column/>
      <pdf-column/>
      <pdf-column/>
      <tr>
       <td>
Dienstgüte
       </td>
       <td>
Parameterwert
       </td>
       <td>
numerischer Wert
       </td>
      </tr>
      <tr>
       <td>
Normal
       </td>
       <td>
Normal-Service
       </td>
       <td>
0x00
       </td>
      </tr>
      <tr>
       <td>
Minimale Kosten
       </td>
       <td>
Minimize-Cost
       </td>
       <td>
0x02
       </td>
      </tr>
      <tr>
       <td>
Maximale Zuverlässigkeit
       </td>
       <td>
Maximize-Reliability
       </td>
       <td>
0x04
       </td>
      </tr>
      <tr>
       <td>
Maximaler Durchsatz
       </td>
       <td>
Maximize-Throughput
       </td>
       <td>
0x08
       </td>
      </tr>
      <tr>
       <td>
Minimale Verzögerung
       </td>
       <td>
Minimize-Delay
       </td>
       <td>
0x10
       </td>
      </tr>
     </table>

     <ul>
      <li>
Minimale Verzögerung (minimum delay)<br/>
Die Übertragungsdauer ist das wichtigste Gütekriterium.
Verbindungen über Glasfaser sind in diesem Falle einer
Übertragung per Satellit vorzuziehen.<br/>
Beispiel: ftp, telnet, ssh
      </li>
      <li>
Maximaler Durchsatz (maximum throughput)<br/>
Der Umfang der zu übertragenden Daten ist wichtig,Verzögerungen werden in Kauf genommen. <br/>
Beispiel: ftp-data, www
      </li>
      <li>
Maximale Zuverlässigkeit (maximum reliability)<br/>
Das Paket sollte möglichst zuverlässig übertragen werden,
so dass keine Wiederholungen der Übertagung erforderlich sind.<br/>
Beispiel: snmp, dns
      </li>
      <li>
Minimale Kosten (minimum cost)<br/>
Das Paket ist äußerst unwichtig und sollte demnach
den billigsten Weg einschlagen.<br/>
Beispiel: nntp, smtp
      </li>
     </ul>

     <textblock>
Diese Bits können gesetzt und ausgelesen werden, indem der
numerische Wert oder der Name angegeben wird. Kombinationen
sind nicht sinnvoll.
     </textblock>

     <textblock>
Bsp:
     </textblock>

     <shell>
      <root>
iptables -A FORWARD -m tos --tos 0x10  -j ACCEPT
      </root>
      <root>
iptables -A FORWARD -m tos --tos Minimize-Delay -j ACCEPT
      </root>
     </shell>

     <textblock>
<command>mark</command> (<command>-m mark</command>)
     </textblock>

     <quotation>
Im IP-Header ist etwas Platz zum Markieren von Paketen. Diese
Markierungen können mit der Option <command>--mark</command> ausgelesen werden.
Zum Setzen der Markierung kann die PREROUTING Kette in der
mangle-Tabelle dienen
     </quotation>

     <textblock>
Bsp:
     </textblock>

     <shell>
      <root>
iptables -t filter -A FORWARD -m mark --mark 5 -j Drop
      </root>
     </shell>

     <textblock>
<command>unclean</command>
     </textblock>

     <quotation>
Dieses Modul ist bislang zu wenig getestet und sollte
nicht verwendet werden.
     </quotation>

     <quotation>
multiport, nat, ...
     </quotation>

     <quotation>
werden an dieser Stelle nicht betrachtet.
     </quotation>
    </section>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Ziele der Regeln bestimmen
   </heading>

   <section>
    <heading>
Grundlegendes zu Zielen (Targets)
    </heading>

    <textblock>
Wie bereits erwähnt, beinhaltet jede Kette
(INPUT, OUTPUT, FORWARD) eine Checkliste von
Regeln, die folgendermaßen aussehen:
    </textblock>

    <textblock>
WENN (Filteroption)
DANN Aktion (Löschen, Akzeptieren, ... des Paketes)
    </textblock>

    <shell>
     <root>
iptables -A INPUT -s 127.0.0.1 -p icmp -j DROP
     </root>
    </shell>

    <textblock>
Neben den einfachen, eingebauten Zielen DROP (Paket Verwerfen) und
ACCEPT (Paket annehmen) gibt es spezielle Ziele (RETURN, QUEUE) und
Erweiterungen, die entsprechende Kernelmodule erfordern. Weiterhin
hat man die Möglichkeit, zu benutzerdefinierten Ketten zu
verzweigen.
    </textblock>
   </section>

   <section>
    <heading>
Benutzerdefinierte Ketten
    </heading>

    <textblock>
Ein relativ sicherer Paketfilter kann nur durch ein sehr komplexes
Regelwerk realisiert werden. Um dieses Regelwerk zu strukturieren,
gibt es die Möglichkeit, neben den
<ref iref="Grundlegendes zu iptables">eingebauten Ketten</ref>
(INPUT, OUTPUT und FORWARD) zusätzliche benutzerdefinierte Ketten
zu erstellen.
    </textblock>

    <textblock>
Diese Ketten sollten mit Kleinbuchstaben benannt werden, um
sie besser von den eingebauten unterscheiden zu können.
    </textblock>

    <textblock>
Wenn ein Paket auf eine Regel (beispielsweise der INPUT Kette)
mit dem Ziel einer benutzerdefinierten Kette zutrifft, wird das
Filtern des Paketes in dieser Kette fortgeführt. Sollte tatsächlich
keine Regel in dieser benutzerdefinierten Kette zutreffen, wird
die Suche in der vorherigen Kette fortgesetzt. Benutzerdefinierte
Ketten können zu anderen benutzerdefinierten Ketten verzweigen.
Wenn die Pakete in einer Schleife gefangen sind,
werden sie einfach verworfen (gelöscht).
    </textblock>

    <textblock>
Ein Beispiel  befindet sich im Abschnitt
<ref iref="Schnelle Lösung ohne viele Worte">Schnelle Lösung ohne viele Worte</ref>
    </textblock>
   </section>

   <section>
    <heading>
Erweiterungen der Ziele
    </heading>

    <textblock>
Eine Zielerweiterung besteht aus einem Kernelmodul und einer
optionalen Erweiterung der Kommandozeilenoptionen von <command>iptables</command>.
    </textblock>

    <textblock>
<strong>LOG</strong> (<command>ipt_LOG</command>)
    </textblock>

    <textblock>
Dieses Ziel bietet Kernel-Logging. Damit die LOG-Files
nicht überflutet werden, sollte es mit einem
<command>limit</command> Parameter eingesetzt werden. Folgende Optionen
sind möglich:
    </textblock>

    <textblock>
<command>--log-level</command>
    </textblock>

    <quotation>
Gefolgt von einer Level-Nummer (Priorität) oder einem
Namen (<command>debug</command>, <command>info</command>, <command>notice</command>, <command>warning</command>, <command>err</command>,
<command>crit</command>, <command>alert</command> und <command>emerg</command>).
Im Kapitel über <ref chapter="syslog">syslog</ref> werden diese Level erklärt.
    </quotation>

    <textblock>
<command>--log-prefix</command>
    </textblock>

    <quotation>
Gefolgt von einer Zeichenkette (max. 30 Zeichen), die
zu Beginn der Logmeldung ausgeschrieben wird.
    </quotation>

    <textblock>
<command>--log-tcp-sequence</command>
    </textblock>

    <quotation>
Zeichnet die TCP-Sequenznummer auf. <strong>Achtung: Mögliches
 Sicherheitsrisiko, wenn Benutzer Zugriff auf Log-Files hat!</strong>
    </quotation>

    <textblock>
<command>--log-tcp-options</command>
    </textblock>

    <quotation>
Loggt die Optionen des TCP-Headers
    </quotation>

    <textblock>
<command>--log-ip-options</command>
    </textblock>

    <quotation>
Loggt die Optionen des IP-Headers
    </quotation>

    <textblock>
Beispiel:
    </textblock>

    <shell>
     <root>
iptables -A INPUT -p icmp -m limit --limit 10/s -j LOG --log-level debug --log-prefix "icmp-logging started"
     </root>
    </shell>

    <textblock>
<command>REJECT</command>
    </textblock>

    <quotation>
Dieses Ziel verwirft das Paket und schickt dem Sender eine
ICMP 'port unreachable' Fehlermeldung. Einschränkungen und
weitere Informationen siehe RFC 1122.
    </quotation>

    <textblock>
<command>MIRROR</command>
    </textblock>

    <quotation>
befindet sich noch in einer experimentellen Phase.
    </quotation>

    <quotation>
Die erweiterten Ziele SNAT, DNAT, MASQUERADE und REDIRECT werden
für Network Address Translation verwendet und sind deshalb nur
in der NAT-Tabelle gültig:
    </quotation>

    <textblock>
<command>SNAT</command>
    </textblock>

    <quotation>
Dieses Ziel manipuliert die Quelladresse eines Paketes
(siehe <ref iref="Kombinieren von NAT und Paketfilter">Kombinieren von NAT und Paketfilter</ref>).
Es ist nur in der POSTROUTING-Kette gültig.
    </quotation>

    <textblock>
<command>DNAT</command>
    </textblock>

    <quotation>
Dieses Ziel manipuliert die Zieladresse eines Paketes.
(siehe <ref iref="Kombinieren von NAT und Paketfilter">Kombinieren von NAT und Paketfilter</ref>).
    </quotation>

    <textblock>
<command>MASQUERADE</command>
    </textblock>

    <quotation>
Dieses Ziel wird für die Maskierung von Verbindungen mit
dynamisch zugewiesenen IPs benutzt (für Verbindungen mit
statischen IPs sollte SNAT verwendet werden).
Es ist nur in der POSTROUTING-Kette gültig.
    </quotation>

    <textblock>
<command>REDIRECT</command>
    </textblock>

    <quotation>
Dieses Ziel ändert die Adresse eines Paketes, so dass es
an die lokale Maschine gesendet wird. Es ist nur in den
PREROUTING- und OUTPUT-Ketten gültig und wird vorzugsweise
für <ref chapter="grundlagen_sicherheit">transparente Proxies</ref>
eingesetzt.
    </quotation>

    <textblock>
Beispiel: transparenter Proxy (squid)
    </textblock>

    <shell>
     <root>
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3128
     </root>
    </shell>

    <textblock>
Die folgenden beiden Ziele dienen der Paketmanipulation und
sind nur in der MANGLE-Tabelle gültig:
    </textblock>

    <textblock>
<command>TOS</command>
    </textblock>

    <quotation>
Mit der Option <command>--set-tos</command> kann das Type-of-Service-Feld
geändert werden. Weitere Informationen zu diesem TOS-Feld
gibt es <ref iref="Explizite Erweiterungen">hier</ref>.
    </quotation>

    <textblock>
<command>MARK</command>
    </textblock>

    <quotation>
Mit der Option <command>--set-mark</command> kann der Netfilter-Markierungswert
gesetzt werden. Weitere Informationen gibt es
<ref iref="Explizite Erweiterungen">hier</ref>.
    </quotation>

    <textblock>
Beispiel:
    </textblock>

    <shell>
     <root>
iptables -t mangle -A PREROUTING -p tcp -m multiport --dport 22,25,119,110,143 -j MARK --set-mark 1
     </root>
    </shell>
   </section>

   <section>
    <heading>
Spezielle eingebaute Ziele (RETURN und QUEUE)
    </heading>

    <textblock>
<command>RETURN</command>
    </textblock>

    <quotation>
Bei benutzerdefinierten Ketten bedeutet ein RETURN die direkte
Rückkehr zur aufrufenden Kette. Die Filterung durch die
benutzerdefinerte Kette wird abgebrochen.
    </quotation>

    <quotation>
Bei eingebauten Ketten (INPUT, FORWARD, OUTPUT) wird die
Abarbeitung beendet und es greift die Standard-Policy.
    </quotation>

    <textblock>
<command>QUEUE</command>
    </textblock>

    <quotation>
Hier können Regelentscheidungen durch Anwendungsprogramme
(Benutzerprozesse) getroffen werden. Dazu wird ein
<strong>queue handler</strong> benötigt (für IPv4 gibt es das <command>ip_queue</command> Modul),
der das Paket an ein Anwendungsprogramm überreicht. Wenn
Sie tatsächlich ein Programm entwickeln möchten, sollten Sie
die <command>libipq</command> API verwenden, die mit <command>iptables</command> mitgeliefert wird.
Beispielcode (z.B. <path>redirect.c</path>) finden Sie in der Testsuite
Tools auf dem CVS Server
<ref url="http://cvs.netfilter.org/netfilter/">http://cvs.netfilter.org/netfilter/</ref>.
    </quotation>

    <textblock>
Beispiel:
    </textblock>

    <shell>
     <root>
iptables -A OUTPUT -p icmp -j QUEUE
     </root>
     <root>
ping 141.24.12.2
     </root>
    </shell>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Kombinieren von NAT und Paketfilter
   </heading>

   <textblock>
Mittels NAT (Network Address Translation) können durch eine
Maskierung der internen IP-Adressen private Netze
(z.B. 192.168.1.0/24) mit öffentlichen gekoppelt werden.
   </textblock>

   <textblock>
Es gibt zwei Arten von NAT:
   </textblock>

   <textblock>
Source-NAT (SNAT):
   </textblock>

   <quotation>
Hier wird die Quell-Adresse eines Paketes
manipuliert. SNAT findet nach dem Routing statt.
Masquerading ist ein spezieller Fall von SNAT.
   </quotation>

   <textblock>
Destination-NAT (DNAT):
   </textblock>

   <quotation>
Hier wird die Zieladresse eines Paketes
manipuliert. Es findet vor dem Routing statt.
Ein Beispiel fuer DNAT ist Port-Forwarding.
   </quotation>

   <textblock>
NAT wird nicht in der Filtertabelle sondern in einer eigenen
Tabelle verwaltet. In dieser NAT-Tabelle sind standardmäßig
die Ketten POSTROUTING, PREROUTING und OUTPUT aufgeführt.
   </textblock>

   <image height="150">
    <filename>
nat-tabelle.png
    </filename>
   </image>

   <textblock>
Der Zugriff auf die NAT-Tabelle erfolgt mit der Option <command>-t nat</command>,
die Auswahl der Filtertabelle wie gewoht mit <command>-A</command>. Eine Auflistung
der <command>iptables</command>-Optionen wurde bereits an
<ref iref="Grundlegendes zu iptables">dieser Stelle</ref>
gegeben.
   </textblock>

   <textblock>
Beispiel:<br/>
ankommende Verbindungen an der ppp0-Schnittstelle verwerfen:
   </textblock>

   <textblock>
Maskiere ppp0
   </textblock>

   <shell>
    <root>
iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
    </root>
   </shell>

   <textblock>
Verbiete Verbindungen von außen
   </textblock>

   <shell>
    <root>
iptables -A INPUT -i ppp0 -m state --state NEW,INVALID -j DROP
    </root>
    <root>
iptables -A FORWARD -i ppp0 0 -m state --state NEW,INVALID -j DROP
    </root>
   </shell>

   <textblock>
IP-Forwarding aktivieren
   </textblock>

   <shell>
    <root>
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
    </root>
   </shell>
  </section>
 </split>

 <split>
  <section>
   <heading>
Verbindungsverfolgung (Connection Tracking)
   </heading>

   <section>
    <heading>
Grundlegendes zur Verbindungsverfolgung
    </heading>

    <textblock>
Unter Verbindungsverfolgung oder auch connection tracking
versteht man das Speichern von Statusinformationen einer Verbindung
(z.B. Quell- und Zieladresse, Portnummern, Protokolltyp,
Timeouts,...). Bei <command>iptables</command> ist dafür die <command>state</command>-Option
zuständig (siehe
<ref iref="Explizite Erweiterungen">Explizite Erweiterungen</ref>).
    </textblock>

    <textblock>
Die Verbindungsverfolgung erfolgt entweder in der
PREROUTING- oder in der OUTPUT- Kette. Die Pakete werden
automatisch defragmentiert, Fragmente  (siehe
<ref iref="Fragmente filtern">Fragmente filtern</ref>)
brauchen also nicht behandelt werden.
    </textblock>

    <textblock>
Die Statustabellen für UDP- und TCP Verbindungen werden in
<path>/proc/net/ip_conntrack</path> gehalten. Wie die Einträge in dieser
Tabelle aussehen, wird später gezeigt. Die maximale
Anzahl der Verbindungen, die diese Tabelle aufnehmen kann,
wird in <path>/proc/sys/net/ipv4/ip_conntrack_max</path> gespeichert und
je nach verfügbaren Hauptspeicher mit einem Standardwert
belegt (z.B. 512 MB, ip_conntrack_max = 32760).
    </textblock>

    <textblock>
Die nächsten drei Unterkapiteln erläutern die
Verbindungsverfolgung für die Protokolle udp, tcp und icmp,
im letzten Kapitel wird das FTP-Protokoll behandelt.
    </textblock>
   </section>

   <section>
    <heading>
UDP
    </heading>

    <textblock>
UDP wird auch als verbindungsloses (zustandsloses) Protokoll
bezeichnet, da im Header keine Sequenznummern oder Ähnliches
zu finden sind. Das bedeutet aber nicht, dass man UDP-Verbindungen
nicht aufspüren und verfolgen kann. Es gibt immer noch andere
nützliche Informationen, welche das genau sind, zeigt der folgende
Eintrag in der Statustabelle:
    </textblock>

    <shell>
     <output>
udp  17 21 src=192.168.1.3 dst=192.168.1.88 sport=1032 dport=53 [UNREPLIED] src=192.168.1.88 dst=192.168.1.3 sport=53 dport=1032 use=1
     </output>
    </shell>

    <textblock>
Aus diesem Eintrag kann Folgendes herausgefunden werden:
    </textblock>

    <ul>
     <li>
Protocol = udp (IP Protokollnummer ist 17)
     </li>
     <li>
Der Eintrag läuft nach 21 Sekunden ab, und ist danach nicht mehr gültig.
     </li>
     <li>
Quell und Zieladressen mit entsprechenden Ports der Anfrage
     </li>
     <li>
Quell und Zieladressen mit entsprechenden Ports der erwarteten Antwort
     </li>
     <li>
Die Verbindung ist als UNREPLIED markiert, es wurde also noch nichts empfangen
     </li>
    </ul>

    <textblock>
Die folgenden Regel erlaubt UDP-Verbindungen vom eigenen
Rechner (bei einer restriktiven Politik)
    </textblock>

    <shell>
     <root>
iptables -A INPUT  -p udp -m state --state ESTABLISHED -j ACCEPT
     </root>
     <root>
iptables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
     </root>
    </shell>

    <textblock>
Udp Timeouts (Zeitlimits) werden vor dem Kompilieren in
<path>/usr/src/linux/net/ipv4/netfilter/ip_conntrack_proto_udp.c</path>
gesetzt, und zwar genau an dieser Stelle:
    </textblock>

    <file>
     <title>
ip_conntrack_proto_udp.c
     </title>
     <content>
*** Datei /usr/src/linux/net/ipv4/netfilter/ip_conntrack_proto_udp.c
#define UDP_TIMEOUT (30*HZ)
#define UDP_STREAM_TIMEOUT (180*HZ)
****** Ende Datei
     </content>
    </file>

    <textblock>
Eine einzelne TCP-Anforderung wird normalerweise 30 Sekunden
in der Tabelle vorgehalten, im Falle unseres Eintrages
(Beispiel oben) sind es nur noch 21 Sekunden. Das bedeutet, dass
die Verbindungsanfrage bereits seit 9 Sekunden bestand ohne
dass ein Antwortpaket empfangen wurde. Wenn nun ein Antwortpaket
eintrifft, wird das Zeitlimit auf 30 Sekunden zurückgesetzt und
die UNREPLIED Markierung gelöscht. Der Tabelleneintrag hätte
nun folgendes Aussehen:
    </textblock>

    <shell>
     <output>
udp 17 28 src=192.168.1.3 dst=192.168.1.88 sport=1032 dport=53 src=192.168.1.88 dst=192.168.1.3 sport=53 dport=1032 use=1
     </output>
    </shell>

    <textblock>
Sollten mehrere Verbindungsanfragen (multiple requests) und
Verbindungsantworten zwischen gleichen Socket-Paaren auftreten,
so wird ein Stream festgestellt und das Zeitlimit auf 180
Sekunden erhöht. Der Tabelleneintrag hätte nun folgendes
Aussehen:
    </textblock>

    <shell>
     <output>
udp  17 177 src=192.168.1.2 dst=192.168.1.50 sport=1032 dport=53 src=192.168.1.50 dst=192.168.1.2 sport=53 dport=1032 [ASSURED] use=1
     </output>
    </shell>

    <textblock>
Man erkennt die Markierung ASSURED, das bedeutet, dass die
Verbindung am längsten aufrechterhalten wird. Wir erinnern
uns an den Parameter <command>ip_conntrack_max</command>, der die maximale
Verbindungsanzahl festlegte. Bei Erreichen dieses Limits
werden die mit UNREPLIED markierten Verbindungen zuerst
gelöscht und die mit ASSURED Markierten zuletzt.
    </textblock>

    <textblock>
Anmerkung: Es gibt weder für UDP noch für TCP Verbindungen
ein absolutes Zeitlimit.
    </textblock>
   </section>

   <section>
    <heading>
TCP
    </heading>

    <textblock>
Jede TCP-Verbindung wird mittels eines Drei-Wege-Händeschüttelns
(three-way handshake) aufgebaut. Kurz zur Erinnerung:<br/>
Es beginnt mit einer Synchronisationsanforderung (SYN)
des Client, der Server bestätigt diese
Synchronisationsanforderung (SYN+ACK) und
letztendlich bestätigt der Client die aufgebaute Verbindung
(ACK). Alle weiteren TCP-Pakete dieser Verbindung werden
ebenfalls mit einem ACK-Flag gekennzeichnet.
    </textblock>

    <textblock>
Neben SYN und ACK-Flags beinhaltet der TCP-Header eine
32 bit Sequenz (Sequence Number) eine ACK-Nummer
(Acknowledgment Number), sodass ein TCP-Paket eindeutig
einer Verbindung zugewiesen werden kann.
    </textblock>

    <textblock>
Zur Verfolgung von TCP-Verbindungen dienen
beispielsweise folgende Regeln:
    </textblock>

    <shell>
     <root>
iptables -A INPUT  -p tcp -m state --state ESTABLISHED -j ACCEPT
     </root>
     <root>
iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
     </root>
    </shell>

    <section>
     <heading>
Tabelleneinträge während des Verbindungsaufbaus
     </heading>

     <textblock>
An dieser Stelle sollen die Tabelleneinträge während des
Verbindungsaufbau analysiert werden:
     </textblock>

     <textblock>
<strong>1)</strong> Eine Verbindungsanforderung (SYN-Paket) wandert in die
OUTPUT-Kette und wird dort akzeptiert.
     </textblock>

     <shell>
      <output>
tcp  6 119 SYN_SENT src=140.208.5.62 dst=207.46.230.218 sport=1 dport=80 [UNREPLIED] src=207.46.230.218 dst=140.208.5.62 sport=80 dport=1 use=1
      </output>
     </shell>

     <textblock>
Der Verbindungsstatus ist SYN_SENT und die Verbindung wurde
als UNREPLIED markiert.
     </textblock>

     <textblock>
<strong>2)</strong> Nach Empfang eines SYN+ACK Paketes wird der Verbindungsstatus
auf SYN_RECV gesetzt und die UNREPLIED Markierung verschwindet.
     </textblock>

     <shell>
      <output>
tcp  6 57 SYN_RECV src=140.208.5.62 dst=207.46.230.218 sport=1 dport=80 src=207.46.230.218 dst=140.208.5.62 sport=80 dport=1 use=1
      </output>
     </shell>

     <textblock>
<strong>3)</strong> Nun sollte eine Bestätigung, also ein ACK-Paket, folgen.
Dieses müsste dieselbe Sequenznummer wie das ACK Paket
des Servers aufweisen. Bei
Übereinstimmung erhält die Verbindung eine ESTABLISHED Markierung
und der Tabelleneintrag wird als ASSURED markiert.
(Hinweis: Bei Erreichen des ip_conntrack_max Limits werden
die mit UNREPLIED markierten Verbindungen zuerst gelöscht und
die mit ASSURED Markierten zuletzt.)
     </textblock>

     <shell>
      <output>
tcp  6 431985 ESTABLISHED src=140.208.5.62 dst=207.46.230.218 sport=1 dport=80 src=207.46.230.218 dst=140.208.5.62 sport=80 dport=1 [ASSURED] use=1
      </output>
     </shell>
    </section>

    <section>
     <heading>
Die Statustabelle aus Sicht der Verbindungsverfolgung
     </heading>

     <textblock>
Bei der Verbindungsverfolgung gibt es lediglich den Status
NEW, ESTABLISHED, RELATED und INVALID
(<ref iref="Explizite Erweiterungen">Explizite Erweiterungen</ref>).
     </textblock>

     <textblock>
Achtung! Dieser Status ist
<strong>nicht äquivalent</strong>
zum TCP Status. Wenn beispielsweise ein ACK-Paket zu einem
nicht-existierenden Rechner hinter der Firewall versendet wird,
wird ein Verbindungseintrag in der Statustabelle erzeugt, weil
es als erstes Paket einer noch nicht bestehenden Verbindung
(und damit als NEW) gilt. Unter dem Gesichtspunkt, dass solche
ACK Pakete die Statustabelle überfluten können, ist die
folgende Regel sehr sinnvoll:
     </textblock>

     <shell>
      <root>
iptables -A INPUT -p tcp ! --syn -m state --state NEW -j DROP
      </root>
     </shell>

     <textblock>
Diese Regel stellt sicher, dass der Aufbau von TCP-Verbindungen
ausschlißlich durch SYN-Pakete initiiert werden kann. Sie hat
jedoch einen kleinen Nachteil:<br/>
Manchmal treten bei TCP-Verbindungen
äußerst lange Wartezeiten auf, und die korrespondierenden Einträge
verschwinden dann aus der Statustabelle. Wenn aber nun die
Verbindung mit ACK-Paketen (Daten)
von außen fortgesetzt wird, dann verhindert die Regel den
Transport nach innen. Anders ausgedrückt: Die Firewall dachte, die
Verbindung wurde abgebrochen und entfernte deshalb den Eintrag in
der Statustabelle. Das ankommende Datenpaket (ACK) kann keiner
Verbindung zugeordnet werden und gilt deshalb als "NEW". Die
obenstehende Regel blockiert aber TCP-Pakete ohne SYN-Flag, die
zu keiner Verbindung zugeordnet werden können.
[besser Workaround <ref iref="Patches">tcp-window-tracking</ref>]
     </textblock>
    </section>

    <section>
     <heading>
Zeitbeschränkungen (Timeouts)
     </heading>

     <textblock>
Die Zeitbeschränkungen ähneln sehr denen von UDP. Wenn eine
Verbindung ein Paket erhält, wird der Timeout zurückgesetzt.
Die Zeitbeschränkungen sind fest eincompiliert und in der
Datei ersichtlich:<br/>
<path>/usr/src/linux/net/ipv4/netfilter/ip_conntrack_proto_tcp.c</path><br/>
Wichtig sind die folgenden Zeilen:
     </textblock>

     <file>
      <title>
ip_conntrack_proto_tcp.c
      </title>
      <content>
[static unsigned long tcp_timeouts]
= { 30 MINS,    /*      TCP_CONNTRACK_NONE,           */
    5 DAYS,     /*      TCP_CONNTRACK_ESTABLISHED,    */
    2 MINS,     /*      TCP_CONNTRACK_SYN_SENT,       */
    60 SECS,    /*      TCP_CONNTRACK_SYN_RECV,       */
    2 MINS,     /*      TCP_CONNTRACK_FIN_WAIT,       */
    2 MINS,     /*      TCP_CONNTRACK_TIME_WAIT,      */
    10 SECS,    /*      TCP_CONNTRACK_CLOSE,          */
    60 SECS,    /*      TCP_CONNTRACK_CLOSE_WAIT,     */
    30 SECS,    /*      TCP_CONNTRACK_LAST_ACK,       */
    2 MINS,     /*      TCP_CONNTRACK_LISTEN,         */
};
      </content>
     </file>
    </section>

    <section>
     <heading>
Terminierung der Verbindung
     </heading>

     <textblock>
Der Verbindungsabbau kann auf zwei unterschiedliche Arten erfolgen.
Der natürliche Weg (FIN+ACK) wurde kurz skizziert:
     </textblock>

     <file>
      <content>
      Verbindungspartner 1     Verbindungspartner 2
                        .........
                        .........
         FIN+ACK   --->
                        &lt;---    ACK
      </content>
     </file>

     <textblock>
Sollte die Statustabelle den Verbindungswert auf TIME_WAIT setzen,
dann wird der Eintrag nach zwei Minuten automatisch gelöscht.
     </textblock>

     <textblock>
Der andere Weg des Verbindungsabbaus ist, wenn ein
Verbindungspartner ein Reset-Paket sendet (RST-Flag gesetzt).
Reset Pakete werden nicht bestätigt (kein resultierendes
ACK-Paket). Der Verbindungsstatus in der Tabelle wird auf
CLOSE geändert und läuft nach 10 Sekunden ab. Das passiert häufig
bei (ausgelasteten) HTTP-Servern.
     </textblock>
    </section>
   </section>

   <section>
    <heading>
ICMP
    </heading>

    <textblock>
Es gibt nur vier ICMP-Typen, deren Pakete als NEW oder
ESTABLISHED markiert werden können.
    </textblock>

    <ol>
     <li>
Echo request (ping, 8) und echo reply (pong, 0).
     </li>
     <li>
Timestamp request (13) und reply (14).
     </li>
     <li>
Information request (15) und reply (16).
     </li>
     <li>
Address mask request (17) und reply (18).
     </li>
    </ol>

    <textblock>
Die Anforderung (request) wird in jedem fall mit NEW markiert und
die Antwort (reply) mit ESTABLISHED.
    </textblock>

    <textblock>
Pakete anderer ICMP-Typen können nur eine <strong>verwandtschaftliche</strong>
Beziehung zu einer Verbindung haben und werden deshalb mit
RELATED markiert.
    </textblock>

    <textblock>
Hier ein paar Beispiele:
    </textblock>

    <shell>
     <root>
iptables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED, RELATED -j ACCEPT
     </root>
     <root>
iptables -A INPUT  -p icmp -m state --state ESTABLISHED, RELATED  -j ACCEPT
     </root>
    </shell>

    <ol>
     <li>
Ein <command>icmp echo request</command> ist NEW somit in der OUTPUT Kette erlaubt.
     </li>
     <li>
Ein <command>icmp echo reply</command> als Antwort auf einen <command>echo request</command> ist ESTABLISHED und somit in der INPUT Kette erlaubt. Ein <command>echo reply</command> würde immer in der OUTPUT Kette herausgefiltert werden, da keine korrespondierende Echo-Anforderung <command>(echo request</command>) die INPUT-Kette passieren kann.
     </li>
     <li>
Ein <command>icmp redirect</command> gilt als RELATED und passiert somit sowohl INPUT- als auch OUTPUT-Kette, vorausgesetzt es existiert eine korrespondierende TCP- oder UDP-Verbindung in der Statustabelle.
     </li>
    </ol>
   </section>

   <section>
    <heading>
Verbindungsverfolgung und ftp
    </heading>

    <section>
     <heading>
FTP-Freigabe
     </heading>

     <textblock>
Man benötigt das <command>ip_conntrack_ftp</command> Kernelmodul.
     </textblock>

     <textblock>
Für den Hausgebrauch (einzelner PC am Internet) eignen sich
die folgenden zwei Regeln, um FTP-Verbindungen zu akzeptieren:
     </textblock>

     <shell>
      <root>
iptables -A INPUT  -p tcp --sport 21 -m state --state ESTABLISHED -j ACCEPT
      </root>
      <root>
iptables -A OUTPUT -p tcp --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
      </root>
     </shell>

     <textblock>
(Voraussetzung: icmp RELATED wird erlaubt, <ref iref="ICMP">siehe
vorangehendes Unterkapitel</ref>)
     </textblock>

     <textblock>
Leider ist es damit noch nicht getan, eine FTP-Verbindung benötigt
einen eigenständigen Datenkanal, welcher durch zwei
unterschiedliche Arten aufgebaut werden kann. Die folgenden zwei
Unterkapitel beschreiben die Vorgehensweise.
     </textblock>
    </section>

    <section>
     <heading>
Aktives ftp
     </heading>

     <textblock>
Der FTP-Client sendet eine Port-Nummer über den FTP-Kanal
zum FTP-Server. Dieser verbindet sich von Port 20 zu diesem Port
und sendet über diese neue Verbindung (ftp-data) die Daten, z.B.
das Resultat eines <command>ls</command> oder eines <command>get</command>-Kommandos. Die
FTP-Datenverbindung (ftp-data) wird also vom Server aufgebaut,
und nicht wie die FTP-Verbindung vom Client.
     </textblock>

     <textblock>
Um aktives FTP zu erlauben (Der Zielport ist nicht bekannt),
müsste eine generelle Regel für alle einkommenden
Verbindungen von Port 20 (FTP-Server) auf hohe Port-Nummern
(&gt;1023) des Clients anlegt werden. Dies stellt jedoch
eine sehr unsichere Lösung dar.
     </textblock>

     <textblock>
Eine besseren Ansatz besteht in der Verbindungsverfolgung.
Dazu muß das Modul <command>ip_conntrack_ftp</command> eingebunden werden.
Es durchsucht das PORT Kommando nach der
Port-Nummer, mit der sich der Server verbinden wird. Damit kann
eine Beziehung zwischen ftp und ftp-data hergestellt
werden (RELATED). Die folgenden Regeln sind also vollkommen
ausreichend:
     </textblock>

     <shell>
      <root>
iptables -A INPUT  -p tcp --sport 20 -m state --state ESTABLISHED,RELATED -j ACCEPT
      </root>
      <root>
iptables -A OUTPUT -p tcp --dport 20 -m state --state ESTABLISHED -j ACCEPT
      </root>
     </shell>
    </section>

    <section>
     <heading>
Passives ftp
     </heading>

     <textblock>
Im Gegensatz zu aktivem ftp wird die gewünschte PORT-Nummer
der Datenverbindung nicht vom Client sondern vom Server
festgelegt (via PORT-Kommando). Der Client verbindet sich dann
zu diesem Port auf dem Server und der Datenverkehr kann beginnen.
Obwohl diese Vorgehensweise als sicherer gilt, sollte man
bedenken, dass fast gar nichts mehr über die Portnummern
der Verbindung bekannt ist.
     </textblock>

     <textblock>
Analog zu aktiven FTP kann man die Filterregeln aufstellen,
allerdings wird anstelle von NEW für die OUTPUT Kette der
Parameter RELATED angewendet:
     </textblock>

     <shell>
      <root>
iptables -A INPUT  -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED -j ACCEPT
      </root>
      <root>
iptables -A OUTPUT -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED,RELATED -j ACCEPT
      </root>
     </shell>
    </section>
   </section>

   <section>
    <heading>
Patches
    </heading>

    <textblock>
Zur erweiterten Verbindungsverfolgung (andere Protokolle) eignen
sich auch folgende Patches, die unter
<ref lang="de" url="http://www.netfilter.org/documentation/HOWTO/de/netfilter-extensions-HOWTO.html">http://www.netfilter.org/documentation/HOWTO/de/netfilter-extensions-HOWTO.html</ref>
dokumentiert sind und von dort auch heruntergeladen werden
können.
    </textblock>

    <ul>
     <li>
amanda-conntrack-nat
     </li>
     <li>
eggdrop-conntrack
     </li>
     <li>
h323-conntrack-nat
     </li>
     <li>
ip_conntrack-timeouts
     </li>
     <li>
mms-conntrack-nat
     </li>
     <li>
pptp-conntrack-nat
     </li>
     <li>
quake3-conntrack
     </li>
     <li>
rpc
     </li>
     <li>
rsh
     </li>
     <li>
talk-conntrack-nat
     </li>
     <li>
tcp-window-tracking
     </li>
     <li>
tftp-conntrack-nat
     </li>
    </ul>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Testen der Firewall
   </heading>

   <textblock>
Ein erster Test sollte mit dem Netzwerkscanner nmap erfolgen.
Mit ihm kann man sowohl einzelne Rechner als auch ganze Netzwerke
nach Schwachstellen untersuchen. Ein weiterer Netzwerkscanner
ist <ref lang="en" url="http://www.nessus.org/">Nessus</ref>,
der unter der GPL steht und sehr umfangreiche Tests ermöglicht.
   </textblock>

   <textblock>
Man sollte auch unbedingt stets die Log-Files auswerten,
Hilfe dabei bietet das Tool
<ref lang="en" url="http://www.logwatch.org/">logwatch</ref>.
   </textblock>

   <textblock>
Je nach Sicherheitsbedarf ist die Firewall regelmäßig mit den
jeweils aktuellen Versionen der Netzwerkscanner zu testen, denn
Sicherheit ist kein Produkt, sondern ein Prozess,
der niemals als abgeschlossen betrachtet werden soll!
   </textblock>
  </section>

  <section>
   <heading>
Tipps
   </heading>

   <textblock>
Deaktivieren Sie alle Dienste, die Sie nicht unbedingt benötigen!
   </textblock>

   <textblock>
Deinstallieren Sie alles, was zum Arbeiten auf der Maschine nicht
ständig gebraucht wird!
   </textblock>

   <textblock>
Deinstallieren Sie alle Programme mit bekannten
Sicherheitslücken, selbst wenn diese gebraucht werden!
   </textblock>

   <textblock>
Seien Sie stets über Sicherheitslücken informiert!
   </textblock>

   <textblock>
Spielen Sie Updates sofort nach Erscheinen ein!
   </textblock>

   <textblock>
Aktualisieren Sie ständig Ihr System, auch wenn keine Lücke
bekannt gegeben wurde. Hersteller gehen oftmals von aktuellen
Systemen aus.
   </textblock>

   <textblock>
Lesen Sie Artikel zu folgenden Themen:
   </textblock>

   <ul>
    <li>
<ref chapter="syslog">syslog</ref>
    </li>
    <li>
tcp-wrapper
    </li>
    <li>
Proxies (z.B. Squid, SOCKS) <!-- Verweis auf squid setzen, wenn das Kapitel aufgenommen wurde -->
    </li>
    <li>
Einbruchserkennungssystemen (Intrusion Detection Systems) beispielsweise Tripwire und Snort
    </li>
    <li>
SSL, IPsec und IPv6
    </li>
    <li>
<ref chapter="passwoerter">(un)sichere Passwörter</ref>
    </li>
    <li>
Verschlüsselung
    </li>
   </ul>

   <textblock>
und kombinieren Sie diese Maßnahmen.
   </textblock>

   <textblock>
Ein Firewall-Rechner ist ein Firewall-Rechner und nichts
als ein Firewall-Rechner!
   </textblock>

   <textblock>
Eine Firewall kann nur so sicher sein, wie die
Sicherheitspolitik, die sie realisiert. Investieren Sie
also sehr viel Zeit in die Aufstellung einer für Sie
sicheren Politik!
   </textblock>

   <textblock>
Halten Sie sich an das Konzept:
   </textblock>

   <textblock>
<strong>Alles, was nicht ausdrücklich erlaubt wird, ist verboten.</strong>
   </textblock>

   <textblock>
und setzen Sie eine prohibitive Sicherheitspolitik ein.
(Policy = DROP für alle Ketten)!
   </textblock>

   <textblock>
Sicherheit bedeutet Minimalismus, denn
   </textblock>

   <ul>
    <li>
jeder Schnipsel Code kann einen Fehler enthalten,
    </li>
    <li>
jedes Programm und jede Funktion kann auch für etwas verwendet werden, für das sie eigentlich nicht gedacht war,
    </li>
    <li>
bei zuviel Komplexität schleichen sich Fehler ein, die man nur sehr schwer findet,
    </li>
    <li>
die umfangreiche Funktionalität muss ständig aktualisiert werden und
    </li>
    <li>
Probleme potenzieren sich anstatt einander aufzuheben.
(nach Murphy's Gesetz).
    </li>
   </ul>

   <textblock>
Aktivieren Sie <strong>Route Verification</strong>. Das bedeutet,
dass Pakete, die von einer unerwarteten Schnittstelle kommen,
verworfen werden oder anders formuliert: Wenn ein Paket mit
einer Quelladresse des internen Netzwerkes an einer externen
Schnittstelle ankommt, wird es verworfen.
   </textblock>

   <textblock>
Für die Schnittstelle <command>ppp0</command> können Sie es folgendermaßen aktivieren:
   </textblock>

   <shell>
    <root>
echo 1 &gt; /proc/sys/net/ipv4/conf/ppp0/rp_filter
    </root>
   </shell>

   <textblock>
Oder für alle Netzwerkschnittstellen:
   </textblock>

   <file>
    <content>
# for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
#     echo 1 &gt; $f
# done
    </content>
   </file>

   <textblock>
Verwenden Sie Logging nur mit Limit-Option, ansonsten besteht
die Gefahr, dass die Log-Files schnell sehr groß werden und
<strong>überlaufen</strong>.
   </textblock>

   <textblock>
Wenn Sie Sicherheit der Performance vorziehen, sollten Sie
Regeln zur Verbindungsverfolgung  (<strong>connection tracking</strong>)
aufstellen. Es ist eingewisser Overhead nicht vermeidbar,
da meist alle Verbindungen verfolgt werden, aber ein
besser kontrollierter Zugang lässt Sie vielleicht etwas besser
schlafen.
   </textblock>

   <textblock>
Beispiel:
   </textblock>

   <shell>
    <root>
iptables -N no-conns-from-ppp0
    </root>
    <root>
iptables -A no-conns-from-ppp0 -m state --state ESTABLISHED,RELATED -j ACCEPT
    </root>
    <root>
iptables -A no-conns-from-ppp0 -m state --state NEW -i ! ppp0 -j ACCEPT
    </root>
    <root>
iptables -A no-conns-from-ppp0 -i ppp0 -m limit -j LOG --log-prefix "Bad packet from ppp0:"
    </root>
    <root>
iptables -A no-conns-from-ppp0 -i ! ppp0 -m limit -j LOG --log-prefix "Bad packet not from ppp0:"
    </root>
    <root>
iptables -A no-conns-from-ppp0 -j DROP
    </root>
   </shell>

   <shell>
    <root>
iptables -A INPUT -j no-conns-from-ppp0
    </root>
    <root>
iptables -A FORWARD -j no-conns-from-ppp0
    </root>
   </shell>

   <textblock>
Nochmals: Agieren Sie sehr minimalistisch,
umso weniger Sie erlauben, desto weniger Fehler
können sich einschleichen und desto
weniger müssen Sie auch aktualisieren.
   </textblock>
  </section>
 </split>

 <split>
  <section>
   <heading>
Ausblick
   </heading>

   <textblock>
So wie man Sicherheit ständig aktualisieren und pflegen muss,
so hat auch dieses Kapitel regelmäßige Updates und
Erweiterungen nötig. Geplant sind unter anderem Fallbeispiele
mit Skripten zu
   </textblock>

   <ul>
    <li>
Internetanbindung einer einzelne Workstation
    </li>
    <li>
Internetanbindung eines LAN mit Masquerading
    </li>
    <li>
Filterregeln für <command>ssh</command> und <command>apache</command>
    </li>
    <li>
Logging.
    </li>
   </ul>

   <textblock>
Weiterhin wollen wir einen Ausblick auf IPv6 geben, und das
Thema mit Kapiteln zur
   </textblock>

   <ul>
    <li>
Einbruchserkennung
    </li>
    <li>
Spoofing
    </li>
    <li>
Netzwerkscanner,
    </li>
    <li>
Verschlüsselung
    </li>
    <li>
Proxies (Squid und SOCKS) und
    </li>
    <li>
Zusammenspiel des TCP_WRAPPER mit dem Superserver <command>xinetd</command>
erweitern. Und seien sie immer auf der Hut, denn
    </li>
   </ul>

   <textblock>
Es gibt keine absolute Sicherheit!
   </textblock>
  </section>
 </split>

 <split>
  <section>
   <heading>
Anhang
   </heading>

   <section>
    <heading>
Links/ Verweise
    </heading>

    <section>
     <heading>
Allgemein:
     </heading>

     <textblock>
BSI Grundschutzhandbuch
     </textblock>

     <quotation>
<ref lang="de" url="http://www.bsi.bund.de/gshb/deutsch/menue.htm">http://www.bsi.bund.de/gshb/deutsch/menue.htm</ref>
     </quotation>

     <textblock>
DFN-Cert: Firewalls - Klassifikation und Bewertung
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/team/ue/fw/workshop/workshop.html">http://www.cert.dfn.de/team/ue/fw/workshop/workshop.html</ref>
     </quotation>

     <textblock>
(Computer-)Sicherheit allgemein
     </textblock>

     <quotation>
<ref lang="de" url="http://www.ping.at/guides/sicher/">http://www.ping.at/guides/sicher/</ref>
     </quotation>

     <textblock>
Linksammlung Hardening HowTos,
     </textblock>

     <quotation>
<ref lang="en" url="http://www.linux-sec.net/Harden/howto.gwif.html">http://www.linux-sec.net/Harden/howto.gwif.html</ref>
     </quotation>

     <textblock>
DFN- Vortragsfolien
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/events/ws/">http://www.cert.dfn.de/events/ws/</ref><br/>
(Bericht 2002)<br/>
<ref lang="de" url="http://www.cert.dfn.de/dfn/berichte/db093/">http://www.cert.dfn.de/dfn/berichte/db093/</ref>
     </quotation>

     <textblock>
Linux-Security Quick-Start
     </textblock>

     <quotation>
<ref lang="en" url="http://www.linuxsecurity.com/docs/LDP/Security-Quickstart-HOWTO/">http://www.linuxsecurity.com/docs/LDP/Security-Quickstart-HOWTO/</ref>
     </quotation>

     <textblock>
Linux Security HOWTO
     </textblock>

     <quotation>
<ref lang="en" url="http://www.linuxsecurity.com/docs/LDP/Security-HOWTO/">http://www.linuxsecurity.com/docs/LDP/Security-HOWTO/</ref>
     </quotation>
    </section>

    <section>
     <heading>
Sicherheitspflege
     </heading>

     <textblock>
CERT /CC Vulnerability Notes Database
     </textblock>

     <quotation>
<ref lang="en" url="http://www.kb.cert.org/vuls">http://www.kb.cert.org/vuls</ref>
     </quotation>

     <textblock>
DFN-CERT
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/infoserv/">http://www.cert.dfn.de/infoserv/</ref>
     </quotation>

     <textblock>
Bugtraq-Mailingliste
     </textblock>

     <quotation>
<ref lang="en" url="http://online.securityfocus.com/archive">http://online.securityfocus.com/archive</ref>
     </quotation>
    </section>

    <section>
     <heading>
Sicherheit v. Distribution
     </heading>

     <textblock>
SuSE-Linux Security-Updates
     </textblock>

     <quotation>
<ref lang="de" url="http://www.suse.com/de/security/index.html">http://www.suse.com/de/security/index.html</ref>
     </quotation>

     <textblock>
RedHat-Linux
Security-Updates
     </textblock>

     <quotation>
<ref lang="en" url="http://www.redhat.com/apps/support/errata/index.html">http://www.redhat.com/apps/support/errata/index.html</ref><br/>
Securing and Optimizing Red Hat Linux<br/>
<ref lang="en" url="http://www.linuxsecurity.com/docs/Securing-Optimizing-v1.3/">http://www.linuxsecurity.com/docs/Securing-Optimizing-v1.3/</ref>
     </quotation>

     <textblock>
Debian-Linux
Security-Updates
     </textblock>

     <quotation>
<ref lang="de" url="http://www.debian.org/security/">http://www.debian.org/security/</ref><br/>
Securing Debian HOWTO<br/>
<ref lang="en" url="http://www.linuxsecurity.com/docs/harden-doc/html/securing-debian-howto">http://www.linuxsecurity.com/docs/harden-doc/html/securing-debian-howto</ref>
     </quotation>
    </section>

    <section>
     <heading>
weiterführende Artikel
     </heading>

     <textblock>
kleine Sammlung von Online-Artikeln
     </textblock>

     <quotation>
<ref lang="en" url="http://www.linuxsecurity.com/docs/">http://www.linuxsecurity.com/docs/</ref>
     </quotation>

     <textblock>
Snort und Nmap, Linux-Magazin
     </textblock>

     <quotation>
      <ref lang="de" url="http://www.linux-magazin.de/ausgabe/2000/12/SnortNmap/SnortNmap.html">http://www.linux-magazin.de/ausgabe/2000/12/SnortNmap/SnortNmap.html</ref>
     </quotation>

     <textblock>
Tripwire-Artikel, Linux-Magazin
     </textblock>

     <quotation>
<ref lang="de" url="http://www.linux-magazin.de/ausgabe/2001/01/tripwire/tripwire.html">http://www.linux-magazin.de/ausgabe/2001/01/tripwire/tripwire.html</ref><br/>
<ref lang="de" url="http://www.linux-magazin.de/ausgabe/2001/02/tripwire/tripwire.html">http://www.linux-magazin.de/ausgabe/2001/02/tripwire/tripwire.html</ref><br/>
<ref lang="de" url="http://www.linux-magazin.de/ausgabe/2001/03/Tripwire/tripwire.html">http://www.linux-magazin.de/ausgabe/2001/03/Tripwire/tripwire.html</ref>
     </quotation>

     <textblock>
Firewall Handbuch für LINUX 2.0 und 2.2
     </textblock>

     <quotation>
<ref lang="de" url="http://www.little-idiot.de/firewall/zusammen.html">http://www.little-idiot.de/firewall/zusammen.html</ref>
     </quotation>
    </section>

    <section>
     <heading>
Dokumentationen außerhalb Selflinux
     </heading>

     <textblock>
TCP-Wrapper
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/infoserv/dib/dib-1993-07-tcpwrapper/">http://www.cert.dfn.de/infoserv/dib/dib-2002-03-tcpwrapper/</ref>
     </quotation>

     <textblock>
SSH
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/infoserv/dib/dib-2002-01-ssh/">http://www.cert.dfn.de/infoserv/dib/dib-2002-01-ssh/</ref>
     </quotation>

     <textblock>
Distributed Denial of Service Angriffe
     </textblock>

     <quotation>
<ref lang="de" url="http://www.cert.dfn.de/infoserv/dib/dib-2000-01.html">http://www.cert.dfn.de/infoserv/dib/dib-2000-01.html</ref>
     </quotation>
    </section>
   </section>

   <section>
    <heading>
Übersicht über die Standard-Module von IP-Tables
    </heading>

    <table border="1">
     <pdf-column width="150"/>
     <pdf-column/>
     <tr>
      <td>
Modul
      </td>
      <td>
Beschreibung
      </td>
     </tr>
     <tr>
      <td>
<command>ip_conntrack</command>
      </td>
      <td>
Verbindungsverfolgung (connection tracking)
      </td>
     </tr>
     <tr>
      <td>
<command>ip_conntrack_ftp</command>
      </td>
      <td>
Verbindungsverfolgung für FTP
      </td>
     </tr>
     <tr>
      <td>
<command>ip_conntrack_irc</command>
      </td>
      <td>
Verbindungsverfolgung für IRC
      </td>
     </tr>
     <tr>
      <td>
<command>ip_nat_ftp</command>
      </td>
      <td>
NAT-Support für FTP
      </td>
     </tr>
     <tr>
      <td>
<command>ip_queue</command>
      </td>
      <td>
packet queueing (Weiterreichen an Userspace)
      </td>
     </tr>
     <tr>
      <td>
<command>ipchains</command>
      </td>
      <td>
ipchains Kompatibilität
      </td>
     </tr>
     <tr>
      <td>
<command>ipfwadm</command>
      </td>
      <td>
ipfwadm Kompatibilität
      </td>
     </tr>
     <tr>
      <td>
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_limit</command>
      </td>
      <td>
Begrenzungsfilter
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_mac</command>
      </td>
      <td>
Filter für MAC-Adressen
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_multiport</command>
      </td>
      <td>
Filter für mehrere Ports
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_owner</command>
      </td>
      <td>
Filter auf Paketherkunft (UID,GID,PID des lokalen Prozesses)
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_state</command>
      </td>
      <td>
Filter für Verbindungsstatus
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_unclean</command>
      </td>
      <td>
Filter für "komische" Pakete
      </td>
     </tr>
     <tr>
      <td>
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_tos</command>
      </td>
      <td>
Filter für Type Of Service Flags
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_mark</command>
      </td>
      <td>
Filter für MARK-Symbole (markierte Pakete)
      </td>
     </tr>
     <tr>
      <td>
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_LOG</command>
      </td>
      <td>
Ziel zum Logging
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_MARK</command>
      </td>
      <td>
Ziel für Markierung von Paketen
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_MASQUERADE</command>
      </td>
      <td>
Ziel für Masquerading
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_MIRROR</command>
      </td>
      <td>
Ziel zur Spiegelung, noch experimentell
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_REDIRECT</command>
      </td>
      <td>
Ziel zum Umleiten von Paketen
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_REJECT</command>
      </td>
      <td>
Ziel zum Zurückweisen von Paketen
      </td>
     </tr>
     <tr>
      <td>
<command>ipt_TOS</command>
      </td>
      <td>
Ziel für Type Of Service Flags
      </td>
     </tr>
     <tr>
      <td>
<command>iptable_filter</command>
      </td>
      <td>
Tabelle filter
      </td>
     </tr>
     <tr>
      <td>
<command>iptable_mangle</command>
      </td>
      <td>
Tabelle mangle
      </td>
     </tr>
     <tr>
      <td>
<command>iptable_nat</command>
      </td>
      <td>
Tabelle nat
      </td>
     </tr>
    </table>
   </section>

   <section>
    <heading>
Regeln zum Verhindern eines NMAP-Scan
    </heading>

    <shell>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags ALL FIN,URG,PSH
         -j LOG --log-prefix "NMAP-XMAS SCAN:"
         --log-tcp-options --log-ip-options
     </root>
    </shell>

    <shell>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags ALL NONE
         -j LOG --log-prefix "NMAP-NULL SCAN:"
         --log-tcp-options --log-ip-options
     </root>
    </shell>

    <shell>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags SYN,RST SYN,RST
         -j LOG --log-prefix "SYN/RST SCAN:"
         --log-tcp-options --log-ip-options
     </root>
    </shell>

    <shell>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags SYN,FIN SYN,FIN
         -j LOG --log-prefix "SYN/FIN SCAN:"
         --log-tcp-options --log-ip-options
     </root>
    </shell>

    <shell>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
     </root>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags ALL NONE -j DROP
     </root>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
     </root>
     <root>
IPTABLES -t mangle -A PREROUTING
         -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
     </root>
    </shell>
   </section>
  </section>
 </split>
</chapter>
