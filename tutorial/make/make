<?xml version="1.0" encoding="iso-8859-1"?>

<chapter>
 <title>Make</title>

 <author>
  <name>Oliver Böhm</name>
  <mailto>boehm@2xp.de</mailto>
 </author>

 <layout>
  <name>Florian Frank</name>
  <mailto>florian.frank@pingos.org</mailto>
 </layout>

 <license>GFDL</license>

 <index>make</index>

 <split>
  <section>
   <heading>
Einführung
   </heading>

   <textblock>
Stellen Sie sich vor, Sie möchten ein kleines Programm übersetzen und
müssen dazu zu Ihrem Rechner lediglich ein <strong>mach mal</strong> sagen und Ihr
Rechner würde Sie verstehen. Genau zu diesem Zweck gibt es das
<command>make</command>-Kommando. Doch ein
   </textblock>

   <shell>
    <user>
make love
    </user>
   </shell>

   <textblock>
wird vom Rechner leider mit einem
   </textblock>

   <shell>
    <output>
don't know how to make 'love'
    </output>
   </shell>

   <textblock>
quittiert. (das <strong>GNU-make</strong> gibt leider keine so schöne Fehlermeldung
aus). Im Verlauf dieses Kapitels werden wir etwas <strong>Aufklärungsarbeit</strong>
für unser Unix-System betreiben, damit es unseren Wunsch erfüllt.
   </textblock>
  </section>

  <section>
   <heading>
Grundlagen
   </heading>

   <section>
    <heading>
Ein einfaches Makefile
    </heading>

    <textblock>
Basis für unsere Aufklärungsbemühungen ist ein <strong>Makefile</strong>, aus dem
das <command>make</command>-Kommando die nötigen Informationen bezieht, um <strong>love</strong> zu machen:
    </textblock>

    <file>
     <content>
#
#   Makefile for making love
#

love : love.c
        gcc love.c -o love
     </content>
    </file>

    <textblock>
Jetzt weiss das <command>make</command>-Kommando, dass es nach einem <strong>love.c</strong> Ausschau
halten muss, um dann mit Hilfe des Kommandos <strong>gcc love.c -o
love</strong> (Aufruf des GNU-C-Compilers) ein <strong>love</strong> zu generieren.
    </textblock>

    <textblock>
Wenn Sie das Ganze ausprobieren wollen, achten Sie bitte darauf, dass
vor <strong>gcc ...</strong> ein <strong>Tabulator-Zeichen</strong> steht. Für <strong>love.c</strong> können Sie
folgende C-Quelle verwenden:
    </textblock>

    <file>
     <title>
love.c
     </title>
     <content>
main()
{
    printf("Hallo Schatz!\n");
    return 0;
}
     </content>
    </file>

    <textblock>
Jetzt haben wir alle Hilfsmittel beisammen, um den Rechner zu einem
<command>make love</command> aufzufordern:
    </textblock>

    <shell>
     <user>
make love
     </user>
     <output>
gcc love.c -o love
     </output>
    </shell>

    <textblock>
Und tatsächlich: der Rechner erwidert unseren Wunsch mit dem Aufruf
des GNU-Compilers <strong>gcc...</strong>. Sollten Sie eine Fehlermeldung
(zum Beispiel <strong>Makefile:6: *** missing separator...</strong>) erhalten,
überprüfen Sie bitte nochmal das Makefile: die Zeile mit <strong>gcc...</strong>
muss mit einem <strong>Tabulator-Zeichen</strong> beginnen! Wenn Sie das Verzeichnis
auflisten (zum Beispiel mit <command>ls -l</command>), werden Sie feststellen, dass
das <command>make</command>-Kommando tatsächlich ein <strong>love</strong> erzeugt hat, das sich
aufrufen lässt:
    </textblock>

    <shell>
     <user>
./love
     </user>
     <output>
Hallo Schatz!
     </output>
    </shell>

    <textblock>
Die beiden Schritte, Kompilation und Programmaufruf, lassen sich
natürlich auch zusammen im <path>Makefile</path> unterbringen:
    </textblock>

    <file>
     <content>
love : love.c
        gcc love.c -o love
        ./love
     </content>
    </file>

    <textblock>
Damit wird nach erfolgreicher Kompilation das <command>love</command>-Programm
aufgerufen.
    </textblock>
   </section>

   <section>
    <heading>
Regel-Werk
    </heading>

    <textblock>
Ein Makefile enthält Regeln, die die Abhängigkeiten der Quellen
zum Programm, zu Objekt-Dateien, zu <ref chapter="bibliotheken">Bibliotheken</ref> oder auch anderen
Dateien definiert. Eine Regel hat dabei typischerweise folgendes
Aussehen:
    </textblock>

    <file>
     <content>
target: dependencies
        actions
     </content>
    </file>

    <textblock>
Bei <strong>target</strong> handelt es sich um das Ziel, das gebaut werden soll (im
obigen Beispiel war es <strong>love</strong>). Die <strong>dependencies</strong> geben an, wovon das
<strong>target</strong> abhängt (im Beispiel hängt <command>love</command> von <path>love.c</path> ab). Hinter
<strong>actions</strong> verbirgt sich das (oder die) Kommando(s), das/die zum Bau des
Targets notwendig ist/sind. Achten Sie bitte darauf, dass die Zeile mit den
<strong>actions</strong> mit einem <strong>Tabulator-Zeichen</strong> beginnen muss. <strong>actions</strong> darf
dabei aus mehreren Zeilen (= mehrere Kommandos) bestehen, aber alle
diese Zeilen müssen mit dem <strong>Tabulator-Zeichen</strong> beginnen.
    </textblock>

    <textblock>
<strong>Achtung!</strong> Leider unterscheidet sich ein Tabulator-Zeichen optisch nicht
von 8 Leerzeichen. Das <command>make</command>-Kommando sieht das leider etwas enger und
gibt stattdessen eine wenig hilfreiche Fehlermeldung (wie <strong>...missing
separator...</strong> oder Ähnliches) aus.
    </textblock>

    <textblock>
Wenn Sie Kommentare in einem Makefile verwenden wollen, leiten Sie
diese mit dem <strong>#</strong>-Zeichen ein. Ein Kommentar erstreckt sich von <strong>#</strong>
bis Zeilenende.
    </textblock>
   </section>

   <section>
    <heading>
Abhängigkeiten
    </heading>

    <textblock>
Wie kann <command>make</command> wissen, wann es ein Ziel zu bauen hat? Wenn Sie
erneut ein <command>make love</command> versuchen, werden Sie von <command>make</command> einen Korb
bekommen:
    </textblock>

    <shell>
     <user>
make love
     </user>
     <output>
make: 'love' is up to date.
     </output>
    </shell>

    <textblock>
Das Geheimnis liegt in den Abhängigkeiten: immer, wenn das Ziel
(<strong>love</strong>) jünger als seine Abhängigkeiten (<path>love.c</path>) ist, geht <command>make</command>
davon aus, dass es nichts zu tun gibt. Wenn Sie jetzt <path>love.c</path>
editieren und abspeichern, ändert sich dies: jetzt ist <path>love.c</path>
jünger. Ein <command>make love</command> wird daraufhin wieder den C-Compiler
aufrufen.
    </textblock>

    <textblock>
Sie werden sich vielleicht fragen: "Wozu der ganze Aufwand? Ich kann
doch den C-Compiler manuell aufrufen, wenn ich "love.c" editiere". Aber
bei größeren Programmen hat man nicht nur eine C-Quelle, sondern
mehrere. Hier hilft das <command>make</command>-Kommando, den Aufruf des Compilers zu
automatisieren.
    </textblock>

    <file>
     <content>
#
#   Makefile mit mehreren Abhängigkeiten
#

children : mummy.o daddy.o
        gcc mummy.o daddy.o -o children

mummy.o : mummy.c
        gcc -c mummy.c

daddy.o : daddy.c
        gcc -c daddy.c
     </content>
    </file>

    <textblock>
Wie man an diesem Beispiel sieht, können Abhängigkeiten auch
mehrstufig sein. <strong>children</strong> hängt von <strong>mummy.o</strong> und <strong>daddy.o</strong>
ab. <strong>mummy.o</strong> und <strong>daddy.o</strong> sind Objekt-Dateien, die wiederum von
<strong>mummy.c</strong> und <strong>daddy.c</strong> abhängen. Wenn Sie das erste Mal ein <command>make
children</command> eingeben, werden zuerst <strong>mummy.o</strong> und <strong>daddy.o</strong> gebaut, ehe
daraus dann <strong>children</strong> erzeugt wird:
    </textblock>

    <shell>
     <user>
make children
     </user>
     <output>
gcc -c mummy.c
gcc -c daddy.c
gcc mummy.o daddy.o -o children
     </output>
    </shell>

    <textblock>
Wenn Sie jetzt eine der beiden C-Quellen verändern und erneut das
<command>make</command>-Kommando aufrufen, wird nur die Objekt-Datei neu erzeugt, die
<strong>veraltet</strong> ist.
    </textblock>
   </section>

   <section>
    <heading>
Pseudo-Ziele
    </heading>

    <textblock>
Dies sind Ziele, die keine Abhängigkeiten besitzen. Damit können Sie
aber nie <strong>up-to-date</strong> werden mit dem gewünschten Nebeneffekt, dass
von make immer die Aktionen ausgeführt werden, wenn solch ein
Pseudo-Ziel aufgerufen wird:
    </textblock>

    <file>
     <content>
clean :
        rm *.o core
     </content>
    </file>

    <textblock>
Jedes Mal, wenn der Benutzer ein <command>make clean</command> eingibt, wird vom
make-Kommando ein <command>rm *.o core</command> aufgerufen, d.h. es werden sämtliche
Objekt-Dateien (<path>*.o</path>) und <path>core</path>-Dateien (diese werden bei einem
Programm-Absturz angelegt) gelöscht.
    </textblock>

    <textblock>
Weil das Ziel <strong>clean</strong> nie erzeugt wird, wird es als Pseudo-Ziel
bezeichnet.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Makros
   </heading>

   <section>
    <heading>
Syntax
    </heading>

    <textblock>
Man kann auch Variablen innerhalb von Makefiles verwenden. Sie werden
dort als Makros bezeichnet und meistens gross geschrieben. Mit
    </textblock>

    <file>
     <content>
CC = gcc
     </content>
    </file>

    <textblock>
wird ein Makro <strong>CC</strong> mit dem Wert <command>gcc</command> angelegt.  Der Wert darf dabei
auch aus mehreren Wörtern bestehen (Beispiel: CC = <command>gcc -O</command>). Die
Definition darf sich auch über mehrere Zeilen erstrecken, wenn die
Zeile mit <strong>\</strong> aufhört (<strong>Achtung</strong>: bitte darauf achten, dass das <strong>\</strong>
tatsächlich das letzte Zeichen in der Zeile ist und kein Tabulator-
oder Leerzeichen dahintersteht!).
    </textblock>

    <textblock>
Der Aufruf des Makros <strong>CC</strong> kann mit
    </textblock>

    <file>
     <content>
$(CC)
${CC}
     </content>
    </file>

    <textblock>
erfolgen.
    </textblock>
   </section>

   <section>
    <heading>
Vordefinierte Makros
    </heading>

    <textblock>
<command>make</command> kennt schon eine Reihe von vordefinierten Makros. So ist zum Beispiel die
Makrodefinition <strong>CC = cc</strong> dem <command>make</command>-Kommando bereits bekannt. Mit
    </textblock>

    <shell>
     <user>
make -p -f /dev/null
     </user>
    </shell>

    <textblock>
können die internen Makros und Regeln abgefragt werden. Ist man nur an
den Makros interessiert, kann man diese mit Hilfe des <command>grep</command>- und
<command>sort</command>-Kommandos ausfiltern und sortieren:
    </textblock>

    <shell>
     <user>
make -p -f /dev/null | grep " = " | sort
     </user>
    </shell>
   </section>

   <section>
    <heading>
Makro-Übergabe
    </heading>

    <textblock>
Makros können schon vordefiniert sein, Makros können im Makefile
gesetzt werden, Makros können aber auch beim Aufruf von <command>make</command>
übergeben werden:
    </textblock>

    <shell>
     <user>
make love CC=gcc
     </user>
    </shell>

    <textblock>
Soll das Makro aus mehreren Wörtern bestehen, so muss es beim Aufruf
gequotet (d.h. mit einfachen oder doppelten Anführungszeichen
umgeben) werden:
    </textblock>

    <shell>
     <user>
make love CFLAGS="-O -DNDEBUG"
     </user>
    </shell>
   </section>

   <section>
    <heading>
Umgebungs-Variablen
    </heading>

    <textblock>
Umgebungs-Variablen werden innerhalb eines Makefiles genauso wie ein
Makro angesprochen. Damit kann man zum Beispiel eine Variable <strong>CXX</strong> setzen, die
den GNU-C++-Compiler enhalten soll:
    </textblock>

    <textblock>
Bash:
    </textblock>

    <shell>
     <user>
export CXX=g++
     </user>
    </shell>

    <textblock>
C-Shell:
    </textblock>

    <shell>
     <user>
setenv CXX g++
     </user>
    </shell>

    <textblock>
Die Umgebungs-Variable <strong>CXX</strong> steht damit im Makefile als Makro zur
Verfügung, was in der folgenden Regel ausgenutzt wird:
    </textblock>

    <file>
     <content>
hello : hello.cpp
        $(CXX) hello.cpp -o hello
     </content>
    </file>
   </section>

   <section>
    <heading>
Prioritäts-Regeln
    </heading>

    <textblock>
Wenn man dasselbe Makro auf verschiedene Weisen definieren kann, ist es
wichtig, zu wissen, welches Makro im Falle eines Konfliktes
gewinnt. Makros werden nach folgender Reihenfolge aufgelöst:
    </textblock>

    <ol>
     <li>
vordefinierte Makros
     </li>
     <li>
Umgebungs-Variablen
     </li>
     <li>
interne Makros
     </li>
     <li>
Makros über die Kommandozeile
     </li>
    </ol>

    <textblock>
Die Priorität ist aufsteigend, das heisst Makros, die über die Kommandozeile
gesetzt werden, gewinnen immer.
    </textblock>
   </section>

   <section>
    <heading>
String-Substitution
    </heading>

    <textblock>
Makros dürfen sich auf andere Makros beziehen. Betrachten wir dazu
folgendes Beispiel:
    </textblock>

    <file>
     <content>
C_FILES   = daddy.c mummy.c
H_FILES   = children.h
SRC_FILES = $(C_FILES) $(H_FILES)
OBJ_FILES = daddy.o mummy.o
     </content>
    </file>

    <textblock>
Das Mako <strong>SRC_FILES</strong> bezieht sich dabei auf die beiden Makros
<strong>C_FILES</strong> und <strong>H_FILES</strong>. Vergleichen wir jetzt das Makro <strong>C_FILES</strong> mit
<strong>OBJ_FILES</strong>, so stellen wir fest, dass sie bis auf die Endung (<path>.c</path>
bzw. <path>.o</path>) identisch sind. Damit wir nicht jedes Mal die OBJ_FILES
anpassen müssen, wenn sich C_FILES ändert, gibt es die
String-Substitution:
    </textblock>

    <file>
     <content>
OBJ_FILES = $(C_FILES:.c=.o)
     </content>
    </file>

    <textblock>
Damit hängt OBJ_FILES direkt von C_FILES ab, das heißt wenn in C_FILES eine
neue <path>.c</path>-Datei aufgenommen wird, müssen wir OBJ_FILES nicht ändern.
    </textblock>
   </section>

   <section>
    <heading>
Interne Makros
    </heading>

    <textblock>
Neben den vordefinierten Makros gibt es eine Reihe von internen
Makros, die manche Regel vereinfachen können:
    </textblock>

    <table>
     <pdf-column width="75"/>
     <pdf-column/>
     <tr>
      <td>
$@
      </td>
      <td>
Name des aktuellen Zieles
      </td>
     </tr>
     <tr>
      <td>
$?
      </td>
      <td>
Name der abhängigen Dateien, die neuer als das Ziel sind
      </td>
     </tr>
     <tr>
      <td>
$&lt;
      </td>
      <td>
Name der abhängigen Dateien, die neuer als das Ziel sind. (mit Endung)
      </td>
     </tr>
     <tr>
      <td>
$*
      </td>
      <td>
Name der abhängigen Dateien, die neuer als das Ziel sind. (ohne Endung)
      </td>
     </tr>
     <tr>
      <td>
$%
      </td>
      <td>
Name der entsprechenden Objekt-Datei (.o), falls das Ziel eine Bibliothek ist.
      </td>
     </tr>
    </table>

    <textblock>
Beispiel:
    </textblock>

    <file>
     <content>
children: $(OBJ_FILES)
        $(CC) $(CFLAGS) $(OBJ_FILES) -o $@
     </content>
    </file>

    <textblock>
In diesem Beispiel wird von make <strong>$@</strong> durch den Namen des Ziels
(<strong>children</strong>) ersetzt.
    </textblock>

    <textblock>
Will man auf den Dateinamen oder Verzeichnisnamen zugreifen, kann man
dies (ausser bei <strong>$?</strong>) über die Modifier <strong>F</strong> (wie File) oder <strong>D</strong> (wie
Directory).
    </textblock>

    <textblock>
Beispiel:
    </textblock>

    <file>
     <content>
$(*D), $(@F)
     </content>
    </file>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Suffix-Regeln
   </heading>

   <textblock>
Wenn Sie eine Datei mit der Endung <strong>.c</strong> sehen, wissen Sie, dass es
sich um eine C-Datei handelt. Vermutlich wissen Sie auch, dass Sie
einen C-Compiler aufrufen müssen, um daraus eine Objekt-Datei mit der
Endung <strong>.o</strong> zu generieren.
   </textblock>

   <textblock>
Über die Suffix-Regeln kann man make dieses Wissen, wie es aus einer
<strong>.c</strong>-Datei eine <strong>.o</strong>-Datei machen soll, beibringen:
   </textblock>

   <file>
    <content>
#
#   Suffix-Regeln fuer C-Programme
#

.SUFFIXES : .c .o .i

.c.o :
        $(CC) -c $&lt;

.c.i :
        $(CC) -E $&lt; &gt; $@
    </content>
   </file>

   <textblock>
Mit der Zeile <strong>.SUFFIXES</strong> gibt man dem <command>make</command>-Kommando bekannt, welche
Endungen es kennen soll. Sollen außer den drei angegebenen Endungen
<strong>.c</strong>, <strong>.o</strong> und <strong>.i</strong> die bereits bekannten Endungen weiter gelten, kann
man <strong>$(SUFFIXES)</strong> noch auf der rechten Seite ergänzen.
   </textblock>

   <textblock>
Nach der Bekanntgabe der Endungen folgen die Suffix-Regeln: Die Regel
<strong>.c.o</strong> gibt an, wie make aus einer <path>.c</path>-Datei eine <path>.o</path>-Datei machen
soll, und die Regel <strong>.c.i</strong> besagt, wie das Ergebnis des Präprozessors in
einer Datei mit der Endung <path>.i</path> landet.
   </textblock>

   <textblock>
Beispiel:
   </textblock>

   <shell>
    <user>
make love.i
    </user>
    <output>
gcc -E love.c &gt; love.i
    </output>
   </shell>

   <section>
    <heading>
Null-Suffix-Regeln
    </heading>

    <textblock>
Null-Suffix-Regeln sind daran erkennbar, dass die zweite Endung
fehlt:
    </textblock>

    <file>
     <content>
#   Null-Suffix-Regel

.c:
        $(CC) $&lt; -o $@
     </content>
    </file>

    <textblock>
Null-Suffix-Regeln kommen dann zum Einsatz, wenn direkt aus einer
Quell-Datei ein ausführbares Programm ohne Datei-Endung erzeugt
werden soll.
    </textblock>

    <textblock>
Beispiel:
    </textblock>

    <shell>
     <user>
make love
     </user>
     <output>
gcc love.c -o love
     </output>
    </shell>
   </section>

   <section>
    <heading>
Eingebaute Suffix-Regeln
    </heading>

    <textblock>
Viele Regeln hat make schon eingebaut, nicht nur für C und C++. Die
Regeln und Makros können über
    </textblock>

    <shell>
     <user>
make -p -f /dev/null
     </user>
    </shell>

    <textblock>
ausgegeben werden. Wie man dabei sieht, gibt es auch für andere
Sprachen bereits vordefinierte Regeln.
    </textblock>

    <table>
     <pdf-column width="75"/>
     <pdf-column/>
     <tr>
      <th>
Endung
      </th>
      <th>
Bedeutung
      </th>
     </tr>
     <tr>
      <td>
.c
      </td>
      <td>
C-Source
      </td>
     </tr>
     <tr>
      <td>
.cc, .C, .cpp
      </td>
      <td>
C++-Source
      </td>
     </tr>
     <tr>
      <td>
.f
      </td>
      <td>
Fortran
      </td>
     </tr>
     <tr>
      <td>
.gz
      </td>
      <td>
komprimierte Datei (gzip)
      </td>
     </tr>
     <tr>
      <td>
.h
      </td>
      <td>
Header-Datei (C, C++)
      </td>
     </tr>
     <tr>
      <td>
.i
      </td>
      <td>
Dateien nach dem Präprozessor-Lauf
      </td>
     </tr>
     <tr>
      <td>
.l
      </td>
      <td>
lex-Dateien
      </td>
     </tr>
     <tr>
      <td>
.o
      </td>
      <td>
Objekt-Dateien
      </td>
     </tr>
     <tr>
      <td>
.p
      </td>
      <td>
Pascal-Dateien
      </td>
     </tr>
     <tr>
      <td>
.s
      </td>
      <td>
Assembler-Dateien
      </td>
     </tr>
     <tr>
      <td>
.y
      </td>
      <td>
yacc-Dateien
      </td>
     </tr>
     <tr>
      <td>
.Z
      </td>
      <td>
komprimierte Dateien (compress)
      </td>
     </tr>
    </table>
   </section>

   <section>
    <heading>
Konflikt-Behandlung
    </heading>

    <textblock>
Betrachten wir ein Makefile, das nur aus folgender Regel besteht:
    </textblock>

    <file>
     <content>
children : mummy.o daddy.o
     </content>
    </file>

    <textblock>
Dummerweise sind mehrere Suffix-Regeln definiert, wie eine <path>.o</path>-Datei
erzeugt werden kann, zum Beispiel aus einer <path>.c</path>-Datei oder aus einer <path>.cpp</path>-Datei
oder Datei mit anderer Endung. Wenn nur eine entsprechende <path>.c</path>-Datei
da ist, ist alles klar. Aber was, wenn nicht? Dann wird die
Such-Reihenfolge durch die SUFFIXES-Liste bestimmt:
    </textblock>

    <file>
     <content>
.SUFFIXES: .o .c .cpp .f
     </content>
    </file>

    <textblock>
Es wird zuerst nach einer <path>.c</path>-Regel gesucht (<path>.o</path> nach <path>.o</path> macht keinen
Sinn), dann nach einer <path>.cc</path>-Regel und so fort.
    </textblock>
   </section>

   <section>
    <heading>
Eigene Suffix-Regeln
    </heading>

    <textblock>
Eigene Suffix-Regeln wird man dann einführen, wenn
    </textblock>

    <ul>
     <li>
die eingebauten Regeln nicht ausreichen,
     </li>
     <li>
man mit den eingebauten Regeln nicht einverstanden ist.
     </li>
    </ul>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Kommandos
   </heading>

   <textblock>
Da die Kommandos in einer eigenen (Unter-)<ref chapter="was_ist_shell">Shell</ref> ausgeführt werden,
stehen alle Möglichkeiten einer <ref chapter="was_ist_shell">Shell</ref> wie Wildcards,
Ein-/Ausgabe-Umlenkung, ... zur Verfügung.
   </textblock>

   <section>
    <heading>
Wildcards
    </heading>

    <textblock>
Wildcards (im Deutschen auch als Jokerzeichen bezeichnet) können
innerhalb von Kommandos verwendet werden, aber auch in den
Abhängigkeiten einer Regel auftauchen:
    </textblock>

    <file>
     <content>
print : *.c
        lpr *.c
     </content>
    </file>

    <textblock>
Leider haben diese Wildcards eine leicht unterschiedliche Bedeutung:
das erste Wildcard <strong>*.c</strong> innerhalb der Abhängigkeit wird von <command>make</command>
aufgelöst, das Wildcard im Kommando (<strong>lpr *.c</strong>) von der Shell. Während
bei der Shell die <strong>Hidden Files</strong> (das sind diejenige Dateien wie
zum Beispiel <path>.bashrc</path>, die mit einem <strong>.</strong> anfangen) nicht dazugehören,
ist hier das <command>make</command>-Kommando anderer Auffassung.
    </textblock>
   </section>

   <section>
    <heading>
Mehrere Kommandos
    </heading>

    <textblock>
Jede Zeile im Aktions-Teil wird in einer eigenen Unter-<ref chapter="was_ist_shell">Shell</ref>
gestartet. Will man mehrere Kommados auf einmal absetzen, werden diese
hintereinander aufgereiht und jeweils durch einen Strichpunkt (<strong>;</strong>)
voneinander getrennt:
    </textblock>

    <file>
     <content>
clean :
        cd obj ; rm *.o
     </content>
    </file>

    <textblock>
Bei diesem Beispiel ist zu bedenken, dass das zweite Kommando (<command>rm *.o</command>)
auch dann ausgführt wird, wenn der erste Teil (<command>cd obj</command>) nicht geklappt
hat. Deswegen können Kommandos auch über <strong>&amp;&amp;</strong> (UND) verknüpft werden:
    </textblock>

    <file>
     <content>
clean :
        cd obj &amp;&amp; rm *.o
     </content>
    </file>

    <textblock>
Vorteil der UND-Verknüpfung: Schlägt das erste Kommando (<command>cd obj</command>) fehl,
wird das zweite Kommando (<command>rm *.o</command>) auf keinen Fall ausgeführt.
    </textblock>

    <textblock>
Man kann die Kommandos auch auf mehrere Zeilen verteilen, indem man
sie mit dem Backslash (<strong>\</strong>) als allerletztes Zeichen in der Zeile verbindet:
    </textblock>

    <file>
     <content>
clean :
        cd obj &amp;&amp;       \
        rm *.o
     </content>
    </file>

    <textblock>
Dabei ist darauf zu achten, dass der Backslash (<strong>\</strong>) wirklich das letzte
Zeichen in der Zeile ist -- er hebt nämlich die Bedeutung des nächsten
Zeichens (in diesem Fall das Zeilenende) auf. Steht hier ein
Leerzeichen, wird die (nicht vorhandene) Sonderbedeutung des
Leerzeichens aufgehoben.
    </textblock>
   </section>

   <section>
    <heading>
Skript-Programmierung
    </heading>

    <textblock>
Für komplexere Aufgaben kann man eigene Skripte schreiben oder aber
auch direkt im Makefile Programmierkonstrukte der <ref chapter="shellprogrammierung">(Bourne-)Shell</ref>
verwenden (das <command>indent</command>-Kommando formartiert C-Quellen nach den
GNU-C-Konventionen):
    </textblock>

    <file>
     <content>
indent :
        for file in $(C_FILES) ; do     \
            indent $$file ;             \
        done
     </content>
    </file>

    <textblock>
Hier ist darauf zu achten, dass die einzelnen Konstrukte durch einen
Strichpunkt (<strong>;</strong>) voneinander getrennt werden. Erstrecken sich die
Kommandos über mehrere Zeilen, ist dies durch ein Backslash (<strong>\</strong>) am
Zeilenende zu kennzeichnen.
    </textblock>

    <textblock>
Der Zugriff auf Shell-interne Variablen wird durch ein zusätzliches
Dollar-Zeichen (<strong>$</strong>) bewerkstelligt (siehe <strong>$$file</strong> im Beispiel).
    </textblock>
   </section>

   <section>
    <heading>
Fehlercode
    </heading>

    <textblock>
Wenn ein Kommando einen Fehlercode zurückliefert, wird make an dieser
Stelle abgebrochen. Dabei ist unter Unix alles, was einen Rückgabewert
ungleich 0 zurückliefert, ein Fehlercode.
    </textblock>

    <textblock>
Meistens ist dieses Verhalten ja gewünscht, zum Beispiel beim Kompilieren
(was der Normalfall sein dürfte). Aber es gibt auch Situationen, in dem
der Rückgabewert eines Kommandos egal ist, zum Beispiel in
    </textblock>

    <file>
     <content>
clean :
        - rm core
        - rm *.o
     </content>
    </file>

    <textblock>
ist es nicht weiter tragisch, wenn <command>rm core</command> nicht erfolgreich war
(weil es nicht existiert). Der Abbruch im Fehlerfall wird durch ein
vorangestelltes Minus (<strong>-</strong>) vermieden.
    </textblock>

    <textblock>
Manche Kommandos, wie zum Beispiel das <command>rm</command>-Kommando, können meist über die
Option <command>-f</command> gezwungen werden, fehlende Dateien oder andere Ungereimtheiten
zu ignorieren. Damit lässt sich das vorige Beispiel auch folgendermassen
formulieren:
    </textblock>

    <file>
     <content>
clean :
        rm -f core
        rm -f *.o
     </content>
    </file>
   </section>

   <section>
    <heading>
Ausgabe unterdrücken
    </heading>

    <textblock>
Normalerweise wird jedes Kommando, das ausgeführt wird, vorher
ausgegeben. Mit einem vorangestellten <strong>@</strong> kann man das unterdrücken:
    </textblock>

    <file>
     <content>
statistic :
        @ echo ""
        @ echo "      S T A T I S T I C S"
        @ echo ""
        @ echo "   Lines   Words   Bytes Modul"
        @ echo "   --------------------------------"
        @ wc ${SRC_FILES}
        @ echo ""
     </content>
    </file>

    <textblock>
Vor Allem beim <command>echo</command>-Kommando macht es keinen Sinn, dass vor der
eigentlichen Ausgabe das <command>echo</command>-Kommando samt Ausgabe-String ausgegeben
wird.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Projekt-Management
   </heading>

   <textblock>
Für kleinere Programmpakete ist das Makefile meist noch recht
übersichtlich. Allerdings verleiten die vielen Möglichkeiten, die make
bietet, dazu dass man sich schnell im <strong>Regel-Dschungel</strong> die Orientierung
verliert und das Makefile immer mehr ein undurchsichtiges Eigenleben
entwickelt. Und wehe, das Wissen über den Aufbau und Ablauf der
Makefiles konzentriert auf einen einzelnen Spezialisten. Wenn dieser
dann nicht mehr zur Verfügung steht, kann die weitere Pflege und
Wartung der Makefiles den eigentlichen Entwicklungsaufwand übersteigen.
   </textblock>

   <textblock>
Während man bei kleineren Projekten das Makefile notfalls nochmals
aufsetzen kann, ist dies bei größeren Projekten oft mit erheblichem
Aufwand verbunden. Daher sollte man auch (oder gerade) bei Makefiles nach
dem Motto
   </textblock>

   <quotation>
<strong>So einfach wie möglich - aber nicht einfacher</strong>
   </quotation>

   <textblock>
handeln.
   </textblock>

   <textblock>
Dieses Kapitel beschäftigt sich mit verschiedenen Aspekten, wie man
mit <command>make</command> größere Projekte verwalten kann. Später werden wir
Makefile-Richtlinien kennenlernen, die die Einarbeitung und Wartung
von (eigenen oder fremden) Makefiles erleichtern können.
   </textblock>

   <section>
    <heading>
Schwierigkeiten
    </heading>

    <textblock>
Einige der Probleme, die den Einsatz von <command>make</command> erschweren, sind:
    </textblock>

    <ul>
     <li>
Verzeichnis-Baum
     </li>
     <li>
Bedingte Kompilierung (#if ... #endif)
     </li>
     <li>
versteckte Abhängigkeiten (zum Beispiel über Header-Dateien)
     </li>
     <li>
Versionierung
     </li>
    </ul>

    <textblock>
Manche der Probleme resultieren aus Unzulänglichkeiten des Compilers,
manche resultieren aus Annahmen und Beschränkungen einiger Unix-Werkzeuge.
Diese spiegeln sich zum Teil in den eingebauten Suffix-Regeln wieder.
    </textblock>

    <textblock>
Ursprünglich war <command>make</command> nur zur Vereinfachung der Kompilierung gedacht,
hat sich aber über die Jahre zu einem mächtigen Entwicklungswerkzeug
gemausert. Nicht zuletzt auch deswegen, weil es inzwischen eine Reihe
von Werkzeugen gibt, die um make herum gebaut wurden, um die
Einschränkungen aufzuheben.
    </textblock>
   </section>

   <section>
    <heading>
Dummy-Ziele
    </heading>

    <textblock>
In der Praxis werden Dummy-Ziele recht häuig eingesetzt, um mehrere
Ziele zusammenzufassen:
    </textblock>

    <file>
     <content>
# compile all

all : anna berta carmen

anna : anna.c
        $(CC) -g -o anna anna.c

berta : berta.c
        $(CC) -g -o berta berta.c

carmen : carmen.c
        $(CC) -g -o carmen carmen.c
     </content>
    </file>

    <textblock>
Der Entwickler braucht nur <command>make all</command> einzugeben und sämtliche
Programme werden übersetzt.
    </textblock>
   </section>

   <section>
    <heading>
Timestamp-Ziele
    </heading>

    <textblock>
Eine etwas subtilere Variante von Dummy-Zielen sind
<strong>Timestamp</strong>-Targets. Damit werden Ziele bezeichnet, die zwar angelegt
werden, aber nicht als Ziel gebraucht werden. In Wirklichkeit werden
sie zur Synchronisation von Aktivitäten verwendet:
    </textblock>

    <file>
     <content>
TIMESTAMP.strip : anna berta carmen
        strip $?
        touch $@
     </content>
    </file>

    <textblock>
Was macht dieses Ziel? Falls <strong>TIMESTAMP.strip</strong> nicht existiert oder
eines der abhängigen Dateien <strong>anna</strong>, <strong>berta</strong> oder <strong>carmen</strong> neuer ist,
werden die entsprechenden Dateien ge-<command>strip</command>-t (das <command>strip</command>-Kommando
entfernt die Symbol-Tabelle aus dem Programm. Dadurch wird das
Programm kürzer, kann aber dafür nicht mehr debuggt werden.) und danach
<strong>TIMESTAMP.strip</strong> angelegt bzw. mit einem neuen Zeitstempel versehen
(über das <command>touch</command>-Kommando).
    </textblock>

    <textblock>
Die Datei <strong>TIMESTAMP.strip</strong> dient also nur dazu, festzustellen ob
<strong>anna</strong>, <strong>berta</strong> oder <strong>carmen</strong> schon einen <command>strip</command>" hinter sich
haben. Diesen Trick findet man häufiger in Makefiles. Wenn Sie sich
also schon immer gefragt haben, zu was Dateien der Größe <strong>0</strong> gut sein
sollen, hier ist eine mögliche Antwort.
    </textblock>

    <textblock>
Allerdings hat diese Lösung auch einen Haken: man sieht der Datei
<strong>TIMESTAMP.strip</strong> nicht an, zu was sie gut sein soll und ein
ordnungsliebender Mensch könnte leicht auf die Idee kommen, diese Datei zu
löschen, da sie die Größe <strong>0</strong> hat - weg damit! Daher ist es besser,
dieser Datei einen sinnvollen Inhalt zu geben, damit sie
    </textblock>

    <ul>
     <li>
eine Größe &gt; 0 hat und
     </li>
     <li>
damit der ahnungslose Benutzer einen Schimmer bekommt,
zu was diese Datei gut sein könnte.
     </li>
    </ul>

    <textblock>
Dies kann man zum Beispiel durch folgende Regel erreichen:
    </textblock>

    <file>
     <content>
TIMESTAMP.strip : anna berta carmen
        strip $?
        echo "last strip of anna, berta or carmen:" > $@
        date >> $@
     </content>
    </file>
   </section>

   <section>
    <heading>
Rekursives make
    </heading>

    <textblock>
Am wenigsten problematisch ist es, wenn man sämtliche Dateien in einem
einzigen Verzeichnis hat. Leider ist dieses Vorgehen bei größeren
Projekten nicht praktikabel und üblicherweise hat man seine Dateien
über mehrere Verzeichnisse verteilt.
    </textblock>

    <section>
     <heading>
Verteiltes make
     </heading>

     <textblock>
Eine Möglichkeit, mit dem Verzeichnisbaum fertig zu werden, besteht
darin, in jedes Verzeichnis ein Makefile zu plazieren, das über das
Makefile im übergeordneten Verzeichnis aufgerufen wird.
     </textblock>

     <textblock>
Das oberste Makefile könnte dabei folgendermaßen aussehen:
     </textblock>

     <file>
      <content>
SUBDIRS = src lib

all :
        for d in $(SUBDIRS); do \
            (cd $$d; make all)  \
        done
      </content>
     </file>

     <textblock>
Voraussetzung dafür ist natürlich, dass die drunterliegende Makefiles
ein Ziel <strong>all</strong> besitzen.
     </textblock>
    </section>

    <section>
     <heading>
Weitergabe von Makros
     </heading>

     <textblock>
Der rekursive Aufruf von make ist auch dazu geeignet, Informationen
und Flags durchzureichen.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
CFLAGS     = -O
DEBUGFLAGS = -g $(CFLAGS)

testbin :
        make bin "CFLAGS=$(DEBUGFLAGS)"
      </content>
     </file>

     <textblock>
In diesem Beispiel wird durch <command>make testbin</command> dasselbe Makefile noch ein Mal
aufgerufen, jedoch mit geänderten <strong>CFLAGS</strong>. Mit demselben Verfahren
können auch Makros in drunterliegenden Makefiles überschrieben werden.
     </textblock>

     <textblock>
GNU-<command>make</command> und die meisten <command>make</command>-Versionen besitzen auch ein internes
<strong>MAKE-Makro</strong>. Damit lautet die obere <strong>testbin</strong>-Regel:
     </textblock>

     <file>
      <content>
testbin :
        $(MAKE) bin "CFLAGS=$(DEBUGFLAGS)"
      </content>
     </file>

     <textblock>
Der Vorteil des internen <strong>MAKE-Makros</strong> ist die Weitergabe der Optionen
beim Aufruf von <command>make</command>. Wird beispielsweise make mit der Option <command>-n</command>
aufgerufen, so wird damit auch alle weiteren makes mit <command>-n</command> aufgerufen
(die Option <command>-n</command> zeigt nur die Kommandos an, führt sie aber nicht
aus).
     </textblock>
    </section>

    <section>
     <heading>
Wichtige Makros
     </heading>

     <textblock>
Jedes Makefile hat seine eigenen Makros. Um die Verwaltung und Verwirrung
gering zu halten, sollte jedes Makefile dieselben Makro-Namen
besitzen. Jeder <command>make</command>-Aufruf sollte wichtige Makros weiterreichen.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
all :
        for d in $(SUBDIRS); do       \
            (cd $$d;                  \
            make all "CFLAGS=$(CLAGS) \
                LDFLAGS=$(LDFLAGS)    \
                LIBFLAGS=$(LIBFLAGS)) \
        done
      </content>
     </file>
    </section>
   </section>

   <section>
    <heading>
Header-Dateien
    </heading>

    <textblock>
Objekt-Dateien hängen nicht nur von C-Sourcen, sondern auch von
Header-Dateien ab, d.h. man müsste diese eigentlich mit in die
Abhängigkeiten aufnehmen:
    </textblock>

    <file>
     <content>
love.o : love.c darling.h
        $(CC) love.c
     </content>
    </file>

    <textblock>
Dies wird man aber in den seltensten Fällen in Makefiles antreffen,
und zwar meist aus folgenden Gründen:
    </textblock>

    <ul>
     <li>
Faulheit des Programmierers
     </li>
     <li>
versteckte Abhängigkeiten
     </li>
     <li>
zu dynamisch
     </li>
     <li>
zu großer Overhead
     </li>
    </ul>

    <textblock>
Glücklicherweise erhält der Programmierer hier Unterstützung vom
(GNU-)Compiler: Mit der Option <command>-M</command> generiert der Compiler eine Liste
von Abhängigkeiten, die ins Makefile übernommen werden können:
    </textblock>

    <file>
     <content>
prompt% gcc -M love.c
love.o: love.c darling.h
     </content>
    </file>

    <textblock>
Einfacher geht es mit dem Programm <command>makedepend</command>:
    </textblock>

    <file>
     <content>
depend:
        makedepend -- $(CFLAGS) -- $(SRC_FILES)
     </content>
    </file>

    <textblock>
Es fügt an das Ende des Makefiles die fehlenden Abhängigkeiten ein:
    </textblock>

    <file>
     <content>
love.o : love.c
        $(CC) love.c

depend:
        makedepend -- $(CFLAGS) -- $(SRC_FILES)

# DO NOT DELETE

love.o: darling.h
     </content>
    </file>

    <textblock>
Zusammen mit der ersten Abhängigkeit (love.o : love.c) wird jetzt
<path>love.c</path> neu übersetzt, wenn sich <path>love.c</path> oder <path>darling.h</path> ändert.
    </textblock>
   </section>

   <section>
    <heading>
Globale Definitionen (include-Anweisung)
    </heading>

    <textblock>
Viele Makefiles innerhalb verschiedener Verzeichnisse eines Projekts
sehen sich in großen Teilen ähnlich: es werden die gleichen <strong>CFLAGS</strong> definiert,
der gleiche Compiler aufgerufen, die gleichen Suffix-Regeln verwendet,
usw. Was liegt näher, als diese Gemeinsamkeiten in einer gemeinsamen
Datei zu verwalten?
    </textblock>

    <textblock>
Glücklicherweise kennen GNU-<command>make</command> und viele andere <command>make</command>-Varianten eine
<strong>include</strong>-Anweisung, mit der diese gemeinsame Datei eingebunden
werden kann:
    </textblock>

    <file>
     <content>
include common.mk
     </content>
    </file>

    <textblock>
Hiermit wird die Datei <path>common.mk</path> eingebunden. Syntaktisch sieht das
ganze dann so aus, dass diese Datei hier an diese Stelle
hineinkopiert wird.
    </textblock>

    <textblock>
Bei der Verwendung der <strong>include</strong>-Anweisung ist darauf zu achten, das
include am Zeilenanfang steht und dahinter mindestens ein Leerzeichen
oder Tabulator-Zeichen folgt.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Richtlinien
   </heading>

   <textblock>
Viele der Richtlinien in diesem Kapitel sind aus den "Makefile
Conventions" für GNU-Programme entnommen
(siehe <ref lang="en" url="http://www.gnu.org/prep/standards_50.html">http://www.gnu.org/prep/standards_50.html</ref>). Über das
<command>automake</command>-Kommando könnnen Makefiles erzeugt werden, die diese
Richtlinien unterstützen.
    </textblock>

   <section>
    <heading>
Allgemeine Konventionen
    </heading>

    <section>
     <heading>
Standard-Shell
     </heading>

     <textblock>
Normalerweise ist die <ref chapter="bash_basic">Bourne-Shell</ref> (/bin/sh) als Standard-<ref chapter="was_ist_shell">Shell</ref>
vordefiniert. Es gibt aber auch <command>make</command>-Varianten, die die Standard-Shell
über die Umgebungs-Variable <strong>SHELL</strong> vererbt bekommen. Um Probleme zu
vermeiden, sollte daher die <ref chapter="bash_basic">Bourne-Shell</ref> über folgendes Makro
     </textblock>

     <file>
      <content>
SHELL = /bin/sh
      </content>
     </file>

     <textblock>
als Standard-<ref chapter="was_ist_shell">Shell</ref> definiert werden.
     </textblock>
    </section>

    <section>
     <heading>
Suffix-Liste
     </heading>

     <textblock>
Die Suffix-Liste sollte explizit gesetzt werden:
     </textblock>

     <file>
      <content>
.SUFFIXES:
.SUFFIXES: .c .o
      </content>
     </file>

     <textblock>
Die erste Zeile löscht die Suffix-Liste, die zweite Zeile setzt dann
explizit die gewünschten Endungen.
     </textblock>

     <textblock>
<strong>Grund</strong>: Verschiedene <command>make</command>-Varianten haben unterschiedliche und
inkompatible Suffix-Listen. Dies kann zu Verwirrungen auf
unterschiedlichen Systemen führen.
     </textblock>
    </section>

    <section>
     <heading>
Programmstart
     </heading>

     <textblock>
Programme im Arbeitsverzeichnis müssen mit <command>./programm</command> gestartet
werden.
     </textblock>

     <textblock>
<strong>Grund</strong>: Das aktuelle Verzeichnis ist nicht immer im Suchpfad
enthalten.
     </textblock>
    </section>
   </section>

   <section>
    <heading>
Utilities
    </heading>

    <section>
     <heading>
Shell-Kommandos
     </heading>

     <textblock>
Auch wenn manche <command>make</command>-Varianten sowohl Korn-Shell- als auch Bash-Syntax
verstehen, sollte man nur die Bourne-Shell-Syntax verwenden.
     </textblock>
    </section>

    <section>
     <heading>
Standard-Kommandos
     </heading>

     <textblock>
Folgende Unix-Kommandos können direkt verwendet werden:
     </textblock>

     <textblock>
cat cmp cp diff echo egrep expr false grep install-info
ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch
true
     </textblock>

     <textblock>
Bei den Optionen sollte man sich auf die gängigen Optionen
beschränken, die auf allen Systemen vorhanden sind.
     </textblock>

     <textblock>
<strong>Grund</strong>: diese Kommandos sind auf allen <ref chapter="was_ist_linux">Linux</ref>- und <ref chapter="was_ist_unix">Unix</ref>-Varianten
vorhanden
     </textblock>
    </section>

    <section>
     <heading>
Kommandoaufrufe
     </heading>

     <textblock>
Alle übrigen Kommandos wie Compiler-Aufruf und andere Programme
sollten in Variablen abgespeichert werden.
     </textblock>

     <textblock>
<strong>Grund</strong>:  Zum einen ist dies änderungsfreundlicher,
zum anderen kann bei Bedarf das Kommando
über die Kommandozeile mitgegeben werden.
     </textblock>
    </section>
   </section>

   <section>
    <heading>
Variablen
    </heading>

    <section>
     <heading>
Kommando-Variablen
     </heading>

     <textblock>
Nach Möglichkeit sollten Variablen genauso wie das Kommando heissen
und mit dem Namen des Kommandos vorbelegt sein.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
YACC = yacc
      </content>
     </file>
    </section>

    <section>
     <heading>
Vordefinierte Variablen
     </heading>

     <table>
      <pdf-column width="75"/>
      <pdf-column width="75"/>
      <pdf-column/>
      <tr>
       <th>
Variable
       </th>
       <th>
Wert
       </th>
       <th>
Beschreibung
       </th>
      </tr>
      <tr>
       <td>
AR
       </td>
       <td>
ar
       </td>
       <td>
Archiver (zum Bibliotheken bauen)
       </td>
      </tr>
      <tr>
       <td>
CC
       </td>
       <td>
cc
       </td>
       <td>
C-Compiler
       </td>
      </tr>
      <tr>
       <td>
CXX
       </td>
       <td>
g++
       </td>
       <td>
C++-Compiler
       </td>
      </tr>
      <tr>
       <td>
CPP
       </td>
       <td>
$(CC) -E
       </td>
       <td>
C-Präprozessor
       </td>
      </tr>
      <tr>
       <td>
FC
       </td>
       <td>
f77
       </td>
       <td>
Fortran-Compiler
       </td>
      </tr>
      <tr>
       <td>
LD
       </td>
       <td>
ld
       </td>
       <td>
Linker, Loader
       </td>
      </tr>
      <tr>
       <td>
LEX
       </td>
       <td>
lex
       </td>
       <td>
lexikalische Analyse
       </td>
      </tr>
      <tr>
       <td>
MAKE
       </td>
       <td>
make
       </td>
       <td>
make-Kommando
       </td>
      </tr>
      <tr>
       <td>
PC
       </td>
       <td>
pc
       </td>
       <td>
Pascal-Compiler
       </td>
      </tr>
      <tr>
       <td>
YACC
       </td>
       <td>
yacc
       </td>
       <td>
Parser-Generator
       </td>
      </tr>
     </table>

     <textblock>
<strong>Tipp</strong>: Bei der Verwendung von GNU-Make können die vordefinierten
Variablen über
     </textblock>

     <shell>
      <user>
make -p -f /dev/null | grep " = "
      </user>
     </shell>

     <textblock>
ausgegeben werden.
     </textblock>
    </section>

    <section>
     <heading>
Flags
     </heading>

     <textblock>
Flags zu Kommandos sollten in einer Variable mit dem Namen des
Kommandos und der Endung <strong>FLAGS</strong> gekennzeichnet werden (s. Tabelle:
<strong>Flag-Variablen</strong>)
     </textblock>

     <table>
      <pdf-column width="75"/>
      <pdf-column width="75"/>
      <pdf-column width="75"/>
      <pdf-column/>
      <tr>
       <th>
Kommando
       </th>
       <th>
Flags
       </th>
       <th>
Beispiel
       </th>
       <th>
Bemerkung
       </th>
      </tr>
      <tr>
       <td>
AR
       </td>
       <td>
ARFLAGS
       </td>
       <td>
rv
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
CC
       </td>
       <td>
CFLAGS
       </td>
       <td>
-g
       </td>
       <td>
Debug-Flag
       </td>
      </tr>
      <tr>
       <td>
CXX
       </td>
       <td>
CXXFLAGS
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
CPP
       </td>
       <td>
CPPFLAGS
       </td>
       <td>
-DGERMAN
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
FC
       </td>
       <td>
FFLAGAS
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
LD
       </td>
       <td>
LDFLAGS
       </td>
       <td>
-lm
       </td>
       <td>
math. Bibliothek
       </td>
      </tr>
      <tr>
       <td>
LEX
       </td>
       <td>
LEXFLAGS
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
MAKE
       </td>
       <td>
MAKEFLAGS
       </td>
       <td>
-k
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
PC
       </td>
       <td>
PFLAGS
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
YACC
       </td>
       <td>
YFLAGS
       </td>
       <td>
-v
       </td>
       <td>
Verbose-Flag
       </td>
      </tr>
     </table>

     <textblock>
Abweichend von der obigen Namensgebung werden die Flags für den C-Compiler
(<strong>CC</strong>) mit <strong>CFLAGS</strong>, für den Fortran-Compiler (<strong>FC</strong>) mit <strong>FFLAGS</strong>, für
den Pascal-Compiler (<strong>PC</strong>) mit <strong>PFLAGS</strong> und für yacc (<strong>YACC</strong>) mit <strong>YFLAGS</strong>
benannt. Dies hat historische Gründe.
     </textblock>
    </section>

    <section>
     <heading>
Lebenswichtige Flags
     </heading>

     <textblock>
Optionen, die für die Kompilation bzw. Erzeugung des Ziels unbedingt
notwendig sind, werden nicht in diesen Variablen abgespeichert.
     </textblock>

     <textblock>
<strong>Grund</strong>:  Es sollte weiterhin möglich sein, Variablen
über den <command>make</command>-Aufruf oder über Umgebungs-Variablen
zu setzen, ohne dass die Kompilation
schief läuft.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
hugo.o : hugo.c
        $(CC) -c $(CPPFLAGS) $(CFLAGS) hugo.c
      </content>
     </file>
    </section>

    <section>
     <heading>
Install-Variablen
     </heading>

     <textblock>
Die Variable <strong>INSTALL</strong> muss in jedem Makefile definiert sein und zum
Installieren von Dateien dienen.
     </textblock>

     <textblock>
Daneben sollten die Variablen <strong>INSTALL_PROGRAM</strong> und
<strong>INSTALL_DATA</strong> definiert werden, die zur Installation von Programmen
und Daten dienen. Der Standard-Wert dafür sollte <strong>$(INSTALL)</strong> sein.
     </textblock>

     <table>
      <pdf-column/>
      <pdf-column/>
      <pdf-column/>
      <tr>
       <th>
Name
       </th>
       <th>
Standard
       </th>
       <th>
Anmerkung
       </th>
      </tr>
      <tr>
       <td>
INSTALL
       </td>
       <td>
install
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
INSTALL_PROGRAM
       </td>
       <td>
$(INSTALL)
       </td>
       <td>
Installation von Programmen
       </td>
      </tr>
      <tr>
       <td>
INSTALL_DATA
       </td>
       <td>
$(INSTALL) -m 644
       </td>
       <td>
Installation von Daten
       </td>
      </tr>
     </table>

     <textblock>
Für die Installation von Programmen und Dateien sollte immer der
komplette Dateiname und nicht nur der Verzeichnisname verwendet
werden.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
install:
        $(INSTALL_PROGRAM) love $(bindir)/love
        $(INSTALL_DATA) loveletter $(datadir)/loveletter
      </content>
     </file>
    </section>
   </section>

   <section>
    <heading>
Installations-Verzeichnis
    </heading>

    <textblock>
Installations-Verzeichnisse sollten immer in Variablen abgelegt
werden, so dass sich die Installation auch leicht an andere
Zielverzeichnisse anpassen lässt.
    </textblock>

    <textblock>
Standardnamen für solche Variablen werden in diesem Abschnitt
beschrieben. Sie basieren auf Standard-Dateisystemen von SVR4,
4.4BSD, Linux, Ultrix V4 und anderer moderner Betriebssysteme.
    </textblock>

    <section>
     <heading>
Root-Installations-Verzeichnis
     </heading>

     <textblock>
Aus folgenden zwei Varablen sollten alle weitere
Installations-Variablen abgeleitet werden:
     </textblock>

     <table>
      <pdf-column width="75"/>
      <pdf-column/>
      <tr>
       <td>
prefix:
       </td>
       <td>
Diese Variable enthält das Basis-Verzeichnis.
       </td>
      </tr>
      <tr>
       <td>
exec_prefix:
       </td>
       <td>
Diese Variable enthält das Basis-Verzeichnis für
einige ausführbare Programme.
Als Standard-Wert enthält diese Variable den
Wert von prefix.
       </td>
      </tr>
     </table>

     <table>
      <pdf-column width="75"/>
      <pdf-column width="125"/>
      <pdf-column/>
      <tr>
       <th>
Variable
       </th>
       <th>
Standard
       </th>
       <th>
Beschreibung
       </th>
      </tr>
      <tr>
       <td>
bindir
       </td>
       <td>
$(exec_prefix)/bin
       </td>
       <td>
hier werden die ausführbaren Programme für den Benutzer abgelegt
       </td>
      </tr>
      <tr>
       <td>
sbindir
       </td>
       <td>
$(exec_prefix)/sbin
       </td>
       <td>
hier werden die Programme für den System Administrator abgelegt
       </td>
      </tr>
      <tr>
       <td>
libexecdir
       </td>
       <td>
$(exec_prefix)/libexec
       </td>
       <td>
hier werden die Programme abgelegt, die von anderen Programmen benötigt werden
       </td>
      </tr>
      <tr>
       <td>
datadir
       </td>
       <td>
$(prefix)/share
       </td>
       <td>
für Architektur-unabhängige Daten-Dateien, die nicht verändert werden (read-only)
       </td>
      </tr>
      <tr>
       <td>
sysconfdir
       </td>
       <td>
$(prefix)/etc
       </td>
       <td>
Konfigurations-Dateien (read-only), die zu einer Single-Maschine gehören
       </td>
      </tr>
      <tr>
       <td>
sharedstatedir
       </td>
       <td>
$(prefix)/com
       </td>
       <td>
Architektur-unabhängige Daten-Dateien, die vom Programm verändert werden können
       </td>
      </tr>
      <tr>
       <td>
localstatedir
       </td>
       <td>
$(prefix)/var
       </td>
       <td>
lokale Architektur-unabhängige Daten-Dateien, die vom Programm verändert werden können
       </td>
      </tr>
      <tr>
       <td>
libdir
       </td>
       <td>
$(exec_prefix)/lib
       </td>
       <td>
Objekt- und Bibliotheks-Dateien (keine ausführbaren Programme)
       </td>
      </tr>
      <tr>
       <td>
infodir
       </td>
       <td>
$(prefix)/info
       </td>
       <td>
Info-Dateien
       </td>
      </tr>
      <tr>
       <td>
lispdir
       </td>
       <td>
$(datadir)/emacs/site-lisp
       </td>
       <td>
Emacs-Lisp-Dateien
       </td>
      </tr>
      <tr>
       <td>
includedir
       </td>
       <td>
$(prefix)/include
       </td>
       <td>
Header-Dateien
       </td>
      </tr>
      <tr>
       <td>
mandir
       </td>
       <td>
$(prefix)/man
       </td>
       <td>
Verzeichnis für die Manpages
       </td>
      </tr>
      <tr>
       <td>
man1dir
       </td>
       <td>
$(mandir)/man1
       </td>
       <td>
"1"er-Manpage
       </td>
      </tr>
      <tr>
       <td>
man2dir
       </td>
       <td>
$(mandir)/man2
       </td>
       <td>
"2"er-Manpage
       </td>
      </tr>
      <tr>
       <td>
...
       </td>
       <td>
...
       </td>
       <td>
...
       </td>
      </tr>
      <tr>
       <td>
manext
       </td>
       <td>
.1
       </td>
       <td>
Manpage Erweiterung
       </td>
      </tr>
      <tr>
       <td>
man1ext
       </td>
       <td>
.1
       </td>
       <td>
"1"er-Manpage Erweiterung
       </td>
      </tr>
      <tr>
       <td>
man2ext
       </td>
       <td>
.2
       </td>
       <td>
"2"er-Manpage Erweiterung
       </td>
      </tr>
      <tr>
       <td>
...
       </td>
       <td>
...
       </td>
       <td>
...
       </td>
      </tr>
      <tr>
       <td>
srcdir
       </td>
       <td>
-
       </td>
       <td>
Verzeichnis, in dem die Sourcen kompiliert werden
       </td>
      </tr>
     </table>
    </section>
   </section>

   <section>
    <heading>
Standard Targets
    </heading>

    <section>
     <heading>
Notwendige Targets
     </heading>

     <table>
      <pdf-column width="75"/>
      <pdf-column/>
      <tr>
       <td>
all
       </td>
       <td>
Kompilation des gesamten Programms
(möglichst mit der Option "-g")
sollte das Standard-Ziel sein
       </td>
      </tr>
      <tr>
       <td>
install
       </td>
       <td>
Kompilation und Installation des Programms,
der Bibliotheken, usw...
       </td>
      </tr>
      <tr>
       <td>
uninstall
       </td>
       <td>
"install" wieder rückgängig machen
       </td>
      </tr>
      <tr>
       <td>
install-strip
       </td>
       <td>
Installation mit ge-"strip"-ten Programmen
(strip entfernt die Symboltabelle aus einem
Programm)
       </td>
      </tr>
      <tr>
       <td>
clean
       </td>
       <td>
Löschen aller Dateien, die beim Erstellen des
Programms erzeugt werden
       </td>
      </tr>
      <tr>
       <td>
distclean
       </td>
       <td>
lösche alle Dateien, die nicht mehr benötigt werden
       </td>
      </tr>
      <tr>
       <td>
dist
       </td>
       <td>
Distributions-Tarfile erstellen;
die Tar-Datei sollte ein Unterverzeichnis mit dem
Werkzeugname und Versionsnummer enthalten, in
dem sämtliche Programme und Dateien
enthalten sind (zum Beispiel love-1.0.1)
       </td>
      </tr>
      <tr>
       <td>
check
       </td>
       <td>
Selbsttest (Überprüfung des Programms)
       </td>
      </tr>
     </table>
    </section>

    <section>
     <heading>
Nützliche Targets
     </heading>

     <table>
      <pdf-column width="75"/>
      <pdf-column/>
      <tr>
       <td>
mostlyclean
       </td>
       <td>
wie "clean", ausser Bibliotheken und andere
Dateien, die zeitintensiv zu erstellen sind
       </td>
      </tr>
      <tr>
       <td>
TAGS
       </td>
       <td>
Erstellen/Update einer Tags-Tabelle
       </td>
      </tr>
      <tr>
       <td>
info
       </td>
       <td>
Info-Dateien erstellen
       </td>
      </tr>
      <tr>
       <td>
installcheck
       </td>
       <td>
Installation von Test-Dateien und -Verzeichnissen,
die für "check" benötigt werden
       </td>
      </tr>
      <tr>
       <td>
installdirs
       </td>
       <td>
Verzeichnisse, die für "install" erzeugt werden müssen
       </td>
      </tr>
     </table>
    </section>
   </section>
  </section>
 </split>
</chapter>
