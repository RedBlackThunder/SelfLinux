<?xml version="1.0" encoding="ISO-8859-1"?>

<chapter>
 <title>Konzepte</title>

 <author>
  <name>Mike Ashley</name>
  <mailto></mailto>
 </author>

 <layout>
  <name>Matthias Hagedorn</name>
  <mailto>matthias.hagedorn@selflinux.org</mailto>
 </layout>

 <license>
  GFDL
 </license>

 <index>gpg_handbuch_kapitel_1</index>

 <description>
  <textblock>
GnuPG verwendet mehrere kryptographische Verfahren wie
beispielsweise <strong>symmetrische Verschlüsselung</strong>,
<strong>Public-Key-Verschlüsselung</strong> und
<strong>Einweg-Hashing</strong>. Natürlich können Sie GnuPG auch
ohne tiefere Kenntnis dieser Konzepte benutzen, doch wenn Sie GnuPG
effektiv einsetzen möchten, sollten Sie ein wenig Hintergrundwissen
haben.
  </textblock>
  <textblock>
Dieses Kapitel führt in die
grundlegenden kryptographischen Konzepte ein, wie sie von GnuPG
benutzt werden. Andere Bücher behandeln diese Themen viel
detaillierter. Empfehlenswerte Bücher zum tieferen Studium sind
beispielsweise <ref lang="en" url="http://www.counterpane.com/schneier.html">
Bruce Schneiers</ref> "Angewandte Kryptographie" oder Reinhard Wobsts
"Abenteuer Kryptologie". Weitere Literaturhinweise finden sich
im <ref chapter="gpg_handbuch_anhang_b">Anhang B</ref>.
  </textblock>
 </description>

 <split>
  <section>
<!-- *. Kapitel -->
   <heading>
Symmetrische Verschlüsselung
   </heading>


   <textblock>
Eine symmetrische Verschlüsselung benutzt zum Ver- und
Entschlüsseln denselben Schlüssel. Zwei Korrespondenzpartner, die
eine symmetrische Verschlüsselung benutzen, müssen sich vorher
über den Schlüssel einigen. Mit diesem Schlüssel verschlüsselt der
Absender die Nachricht und schickt sie an den Empfänger, der sie
unter Benutzung desselben Schlüssels wiederherstellt. Nach diesem
Prinzip funktionierte beispielsweise die deutsche
<command>Enigma</command>. Die jeweiligen Tages-Schlüssel wurden
als Code-Bücher ausgegeben, und jeden Tag konsultierte dann ein
Funker seine Kopie des Code-Buchs, um den aktuellen Tagesschlüssel
zu ermitteln, mit dem der Funkverkehr für den betreffenden Tag
dann ver- und entschlüsselt wurde. Zu den modernen Beispielen für
symmetrische Verschlüsselungen gehören z.B. Blowfish und IDEA.
   </textblock>


   <textblock>
Ein gutes Verschlüsselungverfahren legt den Schwerpunkt der
Sicherheit auf die Geheimhaltung des Schlüssels und nicht auf die
Geheimhaltung des verwendeten Algorithmus. Mit anderen Worten, es
ist keine Hilfe für einen Angreifer, wenn das
Verschlüsselungsverfahren bekannt ist, solange er nicht im Besitz
des Schlüssels selbst ist. Die von GnuPG benutzten
Verschlüsselungsverfahren beruhen auf diesen Prinzipien.
   </textblock>


   <textblock>
Da die gesamte Sicherheit auf dem Schlüssel beruht, ist es
wichtig, dass der Schlüssel mit verfügbaren Mitteln nicht zu
erraten ist. Daraus folgt, dass der Vorrat an möglichen Schlüsseln,
der sogenannte <strong>key space</strong>, möglichst groß sein
muß. Während seiner Zeit in Los Alamos war der Nobelpreisträger
Richard Feynman berühmt für seine Fähigkeit, Safes zu knacken. Um
es noch geheimnisvoller zu machen, schleppte er einen Satz von
Werkzeugen mit, zu denen ein altes Stethoskop gehörte. In
Wirklichkeit wandte er jedoch eine ganze Reihe von Tricks an, um
die Zahl der Kombinationen, die er ausprobieren mußte, zu
reduzieren; dann fing er an zu raten, bis er die richtige
Kombination fand. Mit anderen Worten, er verringerte die Größe des
<strong>key space</strong>.
   </textblock>

   <textblock>
Die Briten benutzten im 2. Weltkrieg Maschinen, um Schlüssel zu
erraten. Die deutsche <command>Enigma</command> hatte einen sehr
großen <strong>key space</strong>, doch die Briten bauten
spezialisierte Rechenmaschinen, <command>Bombes</command> genannt,
um systematisch alle Schlüssel auszuprobieren, bis der jeweilige
Tagesschlüssel gefunden war. Manchmal fanden sie den
Tagesschlüssel innerhalb der Benutzungsdauer des neuen Schlüssels,
an manchen Tagen fanden sie den richtigen Schlüssel überhaupt
nicht.
   </textblock>


   <textblock>
Heute können Computer sehr schnell Schlüssel erraten, und eben
deshalb ist in modernen Verschlüsselungsverfahren die
Schlüsselgröße äußerst wichtig. Die DES-Verschlüsselung zum
Beispiel benutzt einen 56-Bit-Schlüssel; das bedeutet, dass es
2<sup>56</sup>, also genau 72.057.594.037.927.936 mögliche Schlüssel gibt
(das sind <strong>mehr als 72 Billiarden</strong>). Obwohl das
eine sehr große Zahl ist, kann ein normaler Mehrzweckcomputer den
gesamten <strong>key space</strong> innerhalb von Tagen prüfen.
Ein spezialisierter Computer braucht hierfür möglicherweise nur
ein paar Stunden. Die moderneren Verschlüsselungsverfahren wie
beispielsweise Blowfish und IDEA benutzen sämtlich
128-Bit-Schlüssel, was bedeutet, dass es  2<sup>128</sup>
(340.282.366.920.938.463.463.374.607.431.768.211.456!!!) mögliche
Schlüssel gibt. Dies sind so unglaublich viel mehr Kombinationen
als bei einer 56-Bit-Verschlüsselung, dass sogar selbst dann, wenn
man alle Computer der Welt zusammen arbeiten ließe, das bisherige
Alter des Universums noch eine zu kurze Zeit sein könnte, um den
richtigen Schlüssel zu finden.
   </textblock>
  </section>
 </split>

 <split>
  <section>
<!-- *. Kapitel -->   
   <heading>
Public-Key-Verschlüsselung
   </heading>

   <textblock>
Das Hauptproblem bei symmetrischen Verschlüsselungen ist nicht die
Sicherheit der eingesetzten Verfahren, sondern der Austausch der
Schlüssel. Wenn zwei Kommunikationspartner einmal die Schlüssel
ausgetauscht haben, kann der betreffende Schlüssel für sicheren
Datenaustausch benutzt werden.  Die Frage ist nur, auf welchem
sicheren Wege der Schlüsselaustausch stattgefunden hat.
Wahrscheinlich wäre es für einen Angreifer viel leichter, den
Schlüssel abzufangen, als alle möglichen Schlüssel im <strong>key
 space</strong> auszuprobieren (eine Erfahrung, die die Deutschen
mit ihrer Enigma auch machen mußten). Ein weiteres Problem ist die
Anzahl der insgesamt benutzten Schlüssel. Wenn die Zahl der Leute,
die miteinander kommunizieren wollen,  <strong>n</strong> beträgt,
so werden insgesamt <strong>n(n-1)/2</strong> Schlüssel (also
beispielsweise 45 Schlüssel bei 10 Leuten) benötigt. Dies mag für
eine geringe Personenzahl noch angehen, läßt sich aber bei großen
Personengruppen nicht mehr handhaben.
   </textblock>


   <textblock>
Der Sinn von Verschlüsselungsverfahren mit öffentlichem Schlüssel
besteht darin, dass das Sicherheitsrisiko beim gegenseitigen
Schlüsselaustausch gänzlich vermieden wird. Jeder hat ein
Schlüsselpaar mit einem <strong>öffentlichen</strong> und einem
<strong>geheimen</strong> Schlüssel. Zum Verschlüsseln einer
Nachricht benutzt man den öffentlichen Schlüssel des Empfängers,
und nur dieser kann sie mit seinem geheimen Schlüssel wieder
entschlüsseln.
   </textblock>


   <textblock>
Dadurch löst man das Problem des Schlüsselaustausches bei
symmetrischer Verschlüsselung. Sender und Empfänger brauchen sich
nicht auf einen Schlüssel zu einigen. Erforderlich ist nur, daß
der Absender eine Kopie des öffentlichen Schlüssels des Empfängers
besitzt. Dieser eine öffentliche Schlüssel kann von jedem benutzt
werden, der mit dem Empfänger kommunizieren will. Somit sind dann
insgesamt nur  <strong>n</strong> Schlüsselpaare notwendig, wenn
<strong>n</strong> Leute verschlüsselt miteinander kommunizieren
wollen.
   </textblock>


   <textblock>
Die Verschlüsselung mit öffentlichem Schlüssel beruht auf
sogenannten Falltür-Algorithmen bzw. Einweg-Hashes. Das sind
Funktionen, die leicht zu berechnen sind, doch umgekehrt ist es
praktisch unmöglich, aus dem Ergebnis dieser Hash-Funktionen
wieder den Ausgangswert zu berechnen. So ist es z.B. leicht, zwei
Primzahlen miteinander zu multiplizieren, um eine Nichtprimzahl zu
erhalten, es ist aber schwer, eine Nichtprimzahl in ihre
Primfaktoren zu zerlegen. Falltür-Algorithmen sind ähnlich, haben
aber eine <strong>Falltür</strong>. Das heißt: Wenn ein Stück
Information bekannt ist, kann man leicht die Umkehrfunktion
berechnen. Wenn Sie z.B. eine aus zwei Primfaktoren bestehende
Zahl haben, so macht die Kenntnis eines der Faktoren es leicht,
den zweiten zu berechnen.
   </textblock>

   <textblock>
Angenommen, ein Verfahren beruhe auf der Bildung einer Zahl aus
Primfaktoren, dann enthält der öffentliche Schlüssel eine aus zwei
großen Primfaktoren zusammengesetzte Zahl, und das
Verschlüsselungsverfahren benutzt dann diese Nichtprimzahl zum
Verschlüsseln der Nachricht. Das Verfahren zum Wiederherstellen
dieser Nachricht erfordert dann die Kenntnis der Primfaktoren. So
ist die Entschlüsselung möglich, wenn Sie den privaten Schlüssel
haben, der einen der Faktoren enthält, ist aber praktisch
unmöglich, wenn Sie ihn nicht haben.
   </textblock>


   <textblock>
Wie bei guten symmetrischen Verschlüsselungsverfahren beruht die
Sicherheit auch bei Public-Key-Verfahren ausschließlich auf dem
Schlüssel. Aus diesem Grund kann man die Schlüsselgröße als ein
Maß für die Sicherheit des Systems nehmen. Allerdings kann man die
Größe eines symmetrischen Schlüssels nicht mit der von
Public-Key-Verfahren vergleichen, um Rückschlüsse auf deren
relative Sicherheit ziehen zu können. Bei einem
Brute-Force-Angriff auf eine symmetrische Verschlüsselung mit
einer Schlüsselgröße von 80 Bit muß der Angreifer bis zu 2<sup>80-1</sup>
Schlüssel ausprobieren, um den richtigen Schlüssel zu finden. Bei
einem Brute-Force-Angriff auf eine Public-Key-Verschlüsselung muß
der Angreifer bei einer Schlüsselgröße von 512 Bit eine in 512 Bit
codierte (bis zu 155 Dezimalstellen umfassende) Nichtprimzahl in
ihre Primfaktoren zerlegen. Der Rechenaufwand für den Angriff
weist je nach der Verschlüsselung gewaltige Unterschiede auf.
Während 128 Bit für symmetrische Schlüssel ausreichen, werden
angesichts der heutigen Verfahren zur Faktorisierung grosser
Zahlen für die meisten Zwecke öffentliche Schlüssel mit 1024 Bits
empfohlen.
   </textblock>
  </section>
 </split>

 <split>
  <section>
<!-- *. Kapitel -->   
   <heading>
Hybride Verschlüsselungsverfahren
   </heading>


   <textblock>
Public-Key-Verschlüsselung ist kein Allheilmittel. Viele
symmetrische Verfahren sind vom Sicherheitsstandpunkt aus
betrachtet wirksamer, und die Ver- und Entschlüsselung ist bei
Public-Key-Verfahren aufwendiger als bei entsprechenden
symmetrischen Systemen, sie sind aber nichtsdestoweniger ein
wirksames Werkzeug für den sicheren Austausch von symmetrischen
Schlüsseln. Das ist die Idee bei hybriden
Verschlüsselungssystemen.
   </textblock>


   <textblock>
Eine hybride Verschlüsselung benutzt sowohl eine symmetrische
Verschlüsselung als auch ein asymmetrisches Public-Key-Verfahren.
Die eigentliche Nachricht wird mit einem symmetrischen
Sitzungsschlüssel verschlüsselt, welcher von einem
Zufallsgenerator erzeugt wird. Dieser Sitzungsschlüssel wird dann
mit dem öffentlichen Schlüssel des Empfängers verschlüsselt.
   </textblock>


   <textblock>
Sowohl PGP als auch GnuPG benutzen hybride
Verschlüsselungsverfahren. Der mit dem öffentlichen Schlüssel des
Empfängers verschlüsselte Sitzungsschlüssel und die symmetrisch
verschlüsselte Nachricht werden automatisch zusammengefaßt. Der
geheime Schlüssel des Empfängers wird zum Entschlüsseln des
Sitzungsschlüssels verwendet, und dieser wird dann zum
Entschlüsseln der eigentlichen Nachricht verwendet.
   </textblock>


   <textblock>
Ein hybrides Verschlüsselungsverfahren ist immer nur so gut wie
der unsicherste Teil, egal ob das die Public-Key-Verschlüsselung
oder die symmetrische Verschlüsselung ist. Da die symmetrischen
Sitzungsschlüssel bei jedem Vorgang neu erzeugt werden, könnte ein
Angreifer - selbst wenn er einen Sitzungsschlüssel entschlüsseln
könnte - nur die mit dem betreffenden Sitzungsschlüssel
verschlüsselte Nachricht entschlüsseln. Er müßte also für jede
weitere Nachricht, die er lesen möchte, erneut einen
Sitzungsschlüssel entschlüsseln.
   </textblock>
  </section>
 </split>

 <split>
  <section>
<!-- *. Kapitel -->   
   <heading>
Digitale Unterschriften
   </heading>


   <textblock>
Eine Hash-Funktion <ref iref="Fußnoten">[*]</ref>ist eine kryptographische
Prüfsumme. Durch
eine eindeutige Funktion wird aus einer Datei eine wesentlich
kürzere Datensequenz erzeugt, die ein eindeutiges Abbild der
Ursprungsdatei ist.
   </textblock>


   <textblock>
Die digitale Unterschrift eines Dokumentes ist das Ergebnis der
Anwendung einer Hash-Funktion auf das Dokument. Um für digitale
Unterschriften brauchbar  zu sein, muß die Hash-Funktion jedoch
zwei wichtige Eigenschaften haben:
   </textblock>


   <textblock>
Erstens sollte es unmöglich sein, zwei Dokumente zu finden, die
dasselbe Hash-Ergebnis haben. Zweitens sollte es bei einem
gegebenen Hash-Ergebnis schwer sein, das ursprünglich Dokument
wiederherzustellen, aus dem dieser Hash erzeugt wurde.
   </textblock>


   <textblock>
Einige Public-Key-Verfahren könnten auch zum Unterschreiben von
Dokumenten benutzt werden. <ref iref="Fußnoten">[**]</ref> Der Unterzeichner
verschlüsselt das
Dokument mit seinem <strong>privaten</strong> Schlüssel. Jeder,
der die Unterschrift prüfen und das Dokument sehen will, benutzt
einfach den öffentlichen Schlüssel des Unterzeichners, um das
Dokument zu entschlüsseln. Dieses Verfahren besitzt in der Tat die
beiden Eigenschaften, die eine gute Hash-Funktion braucht, doch
ist es in der Praxis zu langsam, um effektiv nutzbar zu sein.
   </textblock>


   <textblock>
Besser ist es, spezielle Hash-Algorithmen zu benutzen, welche
diese beiden wichtigen Eigenschaften aufweisen; wie beispielsweise
SHA1 und RIPE-MD160. Bei einem solchen Verfahren wird der
Hash-Wert eines Dokumentes als Unterschrift verwendet. Man kann
die Unterschrift dadurch prüfen, dass man auf die Kopie des
Dokumentes ebenfalls die Hash-Funktion anwendet und den Hash-Wert,
den man erhält, mit dem Hash-Wert des Originaldokumentes
vergleicht. Wenn beide Werte übereinstimmen, dann sind beide
Dokumente identisch.
   </textblock>

   <textblock>
Das Problem ist jetzt natürlich, Hash-Funktionen für digitale
Unterschriften zu benutzen, ohne einem Angreifer das Manipulieren
der Unterschrift zu ermöglichen. Wenn das Dokument und die
Unterschrift unverschlüsselt geschickt werden, könnte ein
Angreifer das Dokument verändern und eine entsprechende neue
xxUnterschrift erzeugen, ohne dass der Empfänger es merkt. Wenn nur
das Dokument verschlüsselt wird, könnte ein Angreifer die
Unterschrift verfälschen und so das Scheitern einer
Unterschriftsprüfung verursachen.

   </textblock>


   <textblock>
Eine dritte Möglichkeit besteht darin, ein hybrides Verfahren zu
benutzen, um sowohl die Unterschrift als auch das Dokument zu
verschlüsseln. Der Unterzeichner benutzt seinen privaten
Schlüssel, und jedermann kann dessen öffentlichen Schlüssel
benutzen, um die Unterschrift und das Dokument zu prüfen. Dies
klingt zwar gut, ist aber in Wirklichkeit Unsinn. Wenn dieses
Verfahren das Dokument wirklich sichern könnte, würde es dieses
auch gegen Verfälschung sichern, und dann wäre die Unterschrift
gar nicht nötig. Das ernstlichere Problem ist jedoch, dass dies
keinen Schutz gegen Verfälschung bietet, weder für die
Unterschrift noch für das Dokument. Bei diesem Verfahren wird nur
der Sitzungsschlüssel für die symmetrische Verschlüsselung unter
Benutzung des privaten Schlüssels des Unterzeichners
verschlüsselt. Jeder kann den öffentlichen Schlüssel benutzen, um
den Sitzungsschlüssel wiederherzustellen. Deshalb ist es für einen
Angreifer einfach, den Sitzungsschlüssel wiederherzustellen und
ihn zum Verschlüsseln von Ersatzdokumenten und
Ersatzunterschriften zu benutzen, die er dann im Namen des
Absenders an andere schickt.
   </textblock>


   <textblock>
Ein wirklich funktionierendes Verfahren ist es, nur die
Unterschrift mit einem Public-Key-Verfahren zu verschlüsseln. Das
heißt, es wird der geheime Schlüssel des Unterzeichners benutzt,
um die digitale Unterschrift zu erzeugen, die dann jeder mit dem
dazugehörigen öffentlichen Schlüssel checken kann. Das
unterzeichnete Dokument kann man unverschlüsselt verschicken, wenn
es öffentlich ist oder verschlüsselt, wenn es vertraulich ist.
<strong>Wenn das Dokument nach dem Unterzeichnen verändert wurde,
 wird die Unterschriftsprüfung negativ ausfallen.</strong> Der von
GnuPG standardmäßig benutzte <strong>Digital Signature
 Algorithm</strong> (<strong>DSA</strong>) arbeitet nach dieser
Methode.
   </textblock>
  </section>
  
<!-- Fußnoten:  Link auf [*] setzen-->
  <section>
<!-- *.* Kapitel -->   
   <heading>
Fußnoten
   </heading>
   
   <textblock name="*">
Eine einfache Hash-Funktion ist <strong>f(x) = 0</strong> für
alle ganzen Zahlen <strong>x</strong>. Eine interessantere
Hash-Funktion ist <strong>f(x) = x mod 37</strong>, welche
<strong>x</strong> auf den Rest von <strong>x</strong> dividiert
durch 37 abbildet.
   </textblock>

   <textblock name="**">
Die Verschlüsselung muß die Eigenschaft haben, dass der aktuelle
öffentliche oder private Schlüssel vom Verschlüsselungsverfahren
als der öffentliche Schlüssel benutzt werden könnte. RSA ist ein
Beispiel eines solchen Verfahrens, ElGamal dagegen
nicht.
   </textblock>

  </section>
 </split>
</chapter>
