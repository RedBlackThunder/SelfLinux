<?xml version="1.0" encoding="iso-8859-1"?>

<chapter>
 <title>Der Web-Proxy Squid</title>

 <author>
  <name>Jörn Bruns</name>
  <mailto>joern_bruns@gmx.de</mailto>
 </author>

 <layout>
  <name>Florian Frank</name>
  <mailto>florian@pingos.org</mailto>
 </layout>

 <license>GPL</license>

 <index>squid</index>

 <split>
  <section>
   <heading>
Der Web-Proxy Squid
   </heading>

   <textblock>
Sollen sich mehrere Surfer einen Web-Zugang teilen, der sicher,
schnell und zudem flexibel ist, bietet sich ein Caching-Web-Proxy
wie Squid an.
   </textblock>

   <textblock>
Squid steht unter der <ref chapter="sl_anhang">GNU GPL</ref>.
Er ist sehr ausgereift, schnell und flexibel.
Deshalb ist er von den Web-Proxies am weitesten verbreitet und wird
gerade in sehr großen Umgebungen, wie Universitäten und großen,
verzweigten Unternehmen, verwendet.
   </textblock>

   <textblock>
Warum sollten wir seine Vorteile nicht auch in kleineren Netzwerken
nutzen?
   </textblock>
  </section>

  <section>
   <heading>
Was macht ein Web-Proxy?
   </heading>

   <textblock>
Zunächst die Vorteile eines Web-Proxies im allgemeinen:
   </textblock>

   <ol>
    <li>
Proxy heißt übersetzt <strong>Stellvertreter</strong>, und als solcher holt er
für die Nutzer die Web-Seiten aus dem Netz. Nach außen ist
netzwerktechnisch nur der Proxy zu sehen, der Zugreifende ist hinter
ihm versteckt und dadurch geschützt.
    </li>
    <li>
Als weitere Fähigkeit kann ein Proxy meist statische Web-Inhalte
zwischenspeichern, was <strong>Caching</strong> genannt wird.  Ein erneuter Zugriff
auf die gleichen Inhalte wird dadurch erheblich beschleunigt, und
das bei gleichzeitig geringerer Netzlast!
    </li>
   </ol>
  </section>
 </split>

 <split>
  <section>
   <heading>
Warum gerade den Squid als Web-Proxy verwenden?
   </heading>

   <textblock>
Der Einsatz des Squid bringt mehrere Vorteile mit sich:
   </textblock>

   <section>
    <heading>
Freie Lizenz
    </heading>

    <textblock>
Squid ist eine Open-Source-Entwicklung unter der <ref chapter="gpl_de">GNU GPL</ref>.
Somit fallen keine Lizenz-Kosten an, der Quelltext ist frei
verfügbar und an eigene Bedürfnisse anpassbar.
    </textblock>
   </section>

   <section>
    <heading>
Squid ist sehr stabil und ausgereift
    </heading>

    <textblock>
Der Squid wird seit vielen Jahren entwickelt und hat sich auch gerade
in größeren Umgebungen, wie Universitäten und großen Firmen, bewährt.
Im Laufe der Entwicklung ist er schneller und vielseitiger geworden,
so dass er sich hinter keinem kommerziellen Proxy verstecken muss.
    </textblock>

    <textblock>
Ein Blick in die gut dokumentierte <path>/etc/squid.conf</path> zeigt, wie viele
Optionen mit dem Squid offen stehen. Und es gibt eine sehr aktive
Gemeinde, die diesen Proxy immer weiter entwicket.
    </textblock>
   </section>

   <section>
    <heading>
Beschleunigung und Entlastung des Internet-Zugangs
    </heading>

    <textblock>
Statische Inhalte, welche einmal abgerufen wurden, können
zwischengespeichert werden. Dazu gehören auch Grafiken von dynamisch
generierten Seiten. Ein erneutes Abrufen solcher Inhalte, auch
von einem anderen Benutzer, kann aus dem Zwischenspeicher bedient
werden. Die Anfrage ist dadurch erheblich schneller beantwortet, der
Internetzugang wird entlastet. Die Aktualität der Seiten wird durch
sehr ausgeklügelte Methoden sichergestellt.
    </textblock>

    <textblock>
Die am häufigsten genutzten Seiten werden im Arbeitsspeicher gehalten
(<strong>hot object</strong>). Die nicht so schnelle Festplatte wird für länger
zurückliegende Zugriffe genutzt.
    </textblock>

    <textblock>
Eine zusätzliche Beschleunigung bewirkt das Zwischenspeichern der
Zuordnung <strong>Name zu IP-Adresse</strong> (<ref chapter="dns">DNS</ref>-Caching).
    </textblock>
   </section>

   <section>
    <heading>
Kontrolle der Zugriffe
    </heading>

    <textblock>
Soll der Zugriff eingeschränkt werden, ist dies über die
Rechtevergabe mit den <strong>Zugriffs-Kontroll-Listen
(Access Control Lists, ACL)</strong> von Squid
flexibel möglich. Sinnvoll kann dies sein, um die Ablenkung durch
die Angebots-Flut des Internets einzuschränken, juristische Probleme
zu vermeiden (z. B. durch pornografische Inhalte in Schulen) oder um
die Online-Kosten im Griff zu halten.
    </textblock>

    <textblock>
Bereits getätigte Zugriffe können übersichtlich ausgewertet werden.
So ist nachvollziehbar, wer welche Seiten aufgesucht und wer wie viel
Daten übertragen hat.
Ebenso kann ermittelt werden, welche URLs am häufigsten aufgesucht
wurden oder auch wieviele Daten insgesamt übertragen wurden.
Zusätzliche Tools, wie <ref lang="en" url="http://www.webalizer.org/">webalizer</ref>
und <command>cachemanager</command>, helfen die Logfiles auszuwerten.
So kann rechtzeitig ermittelt werden, wann die Proxy-Hardware nicht
mehr ausreicht. Oder es können bestimmte Seiten gesperrt werden, die
den Internet-Zugang überstrapazieren.
    </textblock>

    <textblock>
In diesen Kontrollmöglichkeiten liegt natürlich auch die Gefahr, in
die Privatsphäre anderer einzugreifen. Deshalb ist die
Informationsflut in die Logfiles abgestuft deaktivierbar (z. B. mit
dem Parameter <command>client_netmask</command>).
    </textblock>
   </section>

   <section>
    <heading>
Erhöhte Sicherheit
    </heading>

    <textblock>
Eine Firewall kann ein lokales Netz effektiver absichern, wenn sie
einen Proxy wie den Squid verwendet, anstatt nur auf Paketfilterung
zu vertrauen.
Der Grund dafür liegt darin, dass <ref chapter="iptables">Paketfilter</ref> auf
<ref chapter="tcpip">TCP/IP-Ebene</ref>, nicht
aber den Inhalt von HTTP- und FTP-Verbindungen analysieren können.
Proxies können aber genau diese Inhalte erkennen.
    </textblock>

    <textblock>
Zusätzlich können Proxies die Clients des lokalen Netzes erheblich
besser verbergen, als es durch <ref chapter="nat">Network Adress Translation (NAT)</ref>
möglich wäre. Mit Hilfe des Squid kann genau definiert werden, was an den Webserver
übertragen werden soll und was nicht (z. B. mit dem Parameter <command>forwarded_for</command>).
    </textblock>

    <textblock>
Es können einige <ref chapter="grundlagen_sicherheit" iref="Viren">Viren</ref> geblockt werden (z. B. Nimda).
    </textblock>
   </section>

   <section>
    <heading>
Namensauflösung vereinfacht
    </heading>

    <textblock>
Praktisch ist auch, dass ein Proxy die Namensauflösung zu den
IP-Adressen übernimmt. Es muss im internen Netz kein öffentlicher
Name auflösbar sein, was die <ref chapter="dns">DNS-Konfiguration</ref> erleichtert.
    </textblock>
   </section>

   <section>
    <heading>
Große Flexibilität
    </heading>

    <textblock>
Insbesondere in komplexeren Netzwerken ist der Squid-Proxy sehr
flexibel.
    </textblock>

    <textblock>
So kann z. B. genau definiert werden, welche Seiten aus dem
Internet, welche von einem anderen Proxy und welche direkt aus dem
lokalen Netz geholt werden sollen.
    </textblock>

    <textblock>
Es kann über mehrere Standorte ein so genannter <strong>Cache-Verbund</strong>
aufgebaut werden, was die Netzlast deutlich vermindern kann
und die Ausfallsicherheit erhöht.
    </textblock>

    <textblock>
Des weiteren sind zusätzliche Module verfügbar, welche die
Funktionalität des Squid erweitern können. Hierzu zählen z. B.
<ref lang="en" url="http://www.squidguard.org/">SquidGuard</ref> oder auch Module für die Nutzung einer
Windows-Benutzerverwaltung im Squid.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Squid-Konfiguration auf die Schnelle
   </heading>

   <textblock>
Nach der Installation ist der Squid nicht ohne Anpassungen
lauffähig, er muss zunächst über die Datei <path>/etc/squid.conf</path> an die
vorhandene Netzwerk-Situation angepasst werden. Diese Datei ist sehr
gut kommentiert, aber aufgrund der vielen Einstelloptionen auch sehr
umfangreich. Zum Glück können fast alle Optionen unverändert
übernommen werden.
   </textblock>

   <textblock>
Um den Proxy erst einmal zum Laufen zu bringen,
müssen die hier vorgestellten Parameter angepasst werden.
Ergänzend kann auch in die
QUICKSTART-Datei der Squid-Doku geschaut werden (meist unter
<path>/usr/share/doc/squid</path>).
   </textblock>

   <section>
    <heading>
Zugriffs-Rechte
    </heading>

    <textblock>
Die Voreinstellung des Squid ist aus Sicherheitsgründen so, dass
keiner surfen darf.
Die Rechtevergabe ist sehr flexibel und damit leider auch kompliziert.
Es soll der Einfachheit halber zunächst allen Nutzern im eigenen
lokalen Netz Vollzugriff auf das Internet gewährt werden.
    </textblock>

    <textblock>
Für die Rechtevergabe muss zunächst die Zugriffs-Kontroll-Liste
(Access Control List, ACL) definiert werden.
Anschließend wird über den Namen dieser ACL das Recht mit dem
Schlüsselwort <command>http_access</command> zugewiesen. Weitere Details sind zu finden
unter: <ref iref="Rechtevergabe unter Squid im Detail">Rechtevergabe unter Squid im Detail</ref>
    </textblock>

    <textblock>
Die Syntax der ACL:
    </textblock>

    <file>
     <content>
acl &lt;frei_definierbarer_Name&gt; &lt;acl_Typ&gt; &lt;Werte&gt;
     </content>
    </file>

    <textblock>
Angenommen, die PCs des eigenen Netzes verwenden alle IPs aus
dem Bereich <strong>192.168.10.*</strong>,
könnte die Konfiguration für Vollzugriff des eigenen
lokalen Netzes wie folgt aussehen:
    </textblock>

    <file>
     <content>
acl allowed_hosts src 192.168.10.0/255.255.255.0

http_access allow allowed_hosts
http_access deny all
     </content>
    </file>

    <textblock>
Die letzte Zeile ist schon vorhanden, die beiden darüber liegenden
müssen neu angelegt werden.
Die Reihenfolge der <command>http_access</command>-Zeilen ist wichtig!
Für die eigene Nutzung muss natürlich die IP-Netz-Adresse
<strong>192.168.10.0/255.255.255.0</strong> angepasst werden.
    </textblock>
   </section>

   <section>
    <heading>
Größe des Festplatten-Zwischenspeichers
    </heading>

    <textblock>
Dieser Parameter ist nicht zwingend zu verändern, damit Squid
lauffähig wird, aber so wichtig, dass er hier aufgeführt wird.
    </textblock>

    <textblock>
Soll der Zwischenspeicher (<strong>Cache</strong>) viele Objekte enthalten können,
muss die knappe Voreinstellung von 100 MB vergrößert werden.
    </textblock>

    <textblock>
Doch Vorsicht: Es kann leider nicht der gesamte verfügbare Platz
einer Partition genutzt werden, da zusätzlich noch
Verwaltungsdaten Platz benötigen.
Steht dem Squid nicht genügend Platz zur Verfügung, kann er
nicht arbeiten.
Die Angabe der Zwischenspeicher-Größe sollte deshalb immer mindestens
<strong>10%</strong> unter dem Wert des freien Platzes liegen.
    </textblock>

    <textblock>
Die Syntax ist:
    </textblock>

    <file>
     <content>
cache_dir &lt;Pfad zum Zwischenspeicher&gt; &lt;Größe&gt; &lt;nicht zu verändernde Parameter&gt;
     </content>
    </file>

    <textblock>
Soll die Größe z.B. auf 10000MB eingestellt werden, kann folgendes
eingetragen werden:
    </textblock>

    <file>
     <content>
cache_dir /usr/local/squid/var/cache 10000 16 256
     </content>
    </file>
   </section>

   <section>
    <heading>
Squid hinter einer Firewall
    </heading>

    <textblock>
Kann der Squid direkt auf das Internet zugreifen, sollten die beiden
genannten Einstellungen genügen, um erst mal loslegen zu können.
<strong>Direkt zugreifen</strong> bedeutet hier, dass der Proxy über das <strong>Default
Gateway</strong> auf die Ports 80, 443 und 21 im Internet zugreifen kann.
    </textblock>

    <textblock>
Wenn das nicht möglich ist, wird die vorgelagerte Firewall einen
Web-Proxy haben, von dem sich der Squid die Daten holen kann. In
diesem Fall ist zunächst folgendes einzutragen:
    </textblock>

    <file>
     <content>
cache_peer &lt;firewall&gt; parent &lt;Proxy-Port&gt; &lt;Optionen&gt;
     </content>
    </file>

    <textblock>
Zum Beispiel:
    </textblock>

    <file>
     <content>
cache_peer 192.168.10.1 parent 8080 no-query
     </content>
    </file>

    <textblock>
Um sicherzustellen, dass Squid für alle unbekannten, nicht im
eigenen Netz vorkommenden Web-Server auf das Internet zugreift, die
eigenen Web-Server jedoch direkt anspricht, sollte folgendes ergänzt
werden:
    </textblock>

    <file>
     <content>
acl localnet srcdom .selflinux.org

always_direct  allow  localnet
always_direct  allow  allowed_hosts
never_direct allow  all
     </content>
    </file>

    <textblock>
Die eigene Domain, hier <strong>selflinux.org</strong>, muss natürlich angepasst
werden.
Die ACL für die <command>allowed_hosts</command> ist schon weiter oben definiert.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Squid-Daemon starten
   </heading>

   <textblock>
Die Installation von Squid über <ref chapter="software_installation" iref="RPM">RPM</ref>
oder <ref chapter="software_installation" iref="Debian Paket Format">DEB</ref> ermöglicht eine relativ
einfache Inbetriebnahme des Dienstes. In diesen Fällen ist bereits
einiges vorkonfiguriert, was ansonsten von Hand gemacht werden muss
(etwa das Anpassen von Dateisystemrechten oder das Erstellen eines
Init-Skripts).
   </textblock>

   <textblock>
Bevor Squid das erste Mal gestartet wird, muss die
Cache-Verzeichnisstruktur angelegt werden mit:
   </textblock>

   <shell>
    <root>
squid -z
    </root>
   </shell>

   <textblock>
Wer will, kann nun den Squid zunächst im Debug-Modus auf der Konsole starten.
Fehler werden so auf dem Terminal ausgeben, da Squid nicht in den
Hintergrund geschickt wird:
   </textblock>

   <shell>
    <root>
squid -NCd1
    </root>
   </shell>

   <textblock>
Ist alles in Ordnung, sollte folgende Zeile erscheinen:
   </textblock>

   <shell>
    <output>
Ready to serve requests.
    </output>
   </shell>

   <textblock>
Läuft alles zur Zufriedenheit, kann Squid in Zukunft über das von der jeweiligen
Linux-Distribution vorgesehene Startskript gestartet werden, meist durch:
   </textblock>

   <shell>
    <root>
/etc/init.d/squid start
    </root>
   </shell>

   <textblock>
Bei Problemen sollten die Logfiles <path>/var/log/messages</path> und
<path>cache.log</path> untersucht werden.
   </textblock>

   <textblock>
Wo die <path>cache.log</path> abgelegt ist, kann ermittelt werden mit:
   </textblock>

   <shell>
    <root>
grep cache_log /etc/squid.conf
    </root>
   </shell>
  </section>
 </split>

 <split>
  <section>
   <heading>
Rechtevergabe unter Squid im Detail
   </heading>

   <section>
    <heading>
Warum Zugriffsrechte für den Internet-Zugriff?
    </heading>

    <textblock>
Werden die Rechte lediglich so gesetzt wie im Abschnitt
<ref iref="Squid-Konfiguration auf die Schnelle">Squid-Konfiguration auf die Schnelle</ref>
beschrieben, können alle Nutzer auf sämtliche Inhalte des Internet
zugreifen.
    </textblock>

    <textblock>
Das mag als Konfiguration häufig reichen, es können sich daraus
jedoch folgende Nachteile ergeben:
    </textblock>

    <ul>
     <li>
Der Internetzugang ist schnell überlastet und damit langsam.
     </li>
     <li>
Erhöhte Kosten können entstehen.
     </li>
     <li>
Die Nutzer können sich in der Informationsflut des Internets
verlieren (wichtig bei Schulungen/Schülern).
     </li>
     <li>
Es können sich juristische Probleme ergeben, wenn sich z. B. Schüler
pornografische Inhalte anschauen
     </li>
    </ul>
   </section>

   <section>
    <heading>
Umsetzung
    </heading>

    <textblock>
Das Setzen der Rechte unter Squid ist sehr flexibel, aber leider
nicht selbsterklärend.
    </textblock>

    <textblock>
Mit einer ACL wird zunächst festlegt, auf was (Ziel) oder von was
(Quelle) zugegriffen wird.
Über <command>http_access</command> wird dieser ACL anschließend ein Verbot oder eine
Erlaubnis zugewiesen.
    </textblock>

    <section>
     <heading>
ACL-Elemente - Ziel oder Quelle definieren
     </heading>

     <textblock>
Die Syntax einer ACL sieht folgendermaßen aus:
     </textblock>

     <file>
      <content>
acl &lt;frei_definierbarer_acl_Name&gt; &lt;acl-Typ&gt; &lt;Wert ...&gt;
      </content>
     </file>

     <textblock>
Über den frei definierten ACL-Namen kann mit Hilfe des
unten erläuterten <command>http_access</command> das gewünschte Recht vergeben werden.
Diese ACL-Namen dürfen natürlich nicht doppelt vergeben werden.
     </textblock>

     <textblock>
Es können verschiedene Arten von Quellen und Zielen zur
ACL-Definition verwendet werden.
Hier die für die Zugriffsverwaltung genutzten ACL-Typen:
     </textblock>

     <ul>
      <li>
<command>src</command>: Absender-IP-Adressen der Client-PCs, die über Squid
auf Web-Inhalte zugreifen wollen.
      </li>
      <li>
<command>dst</command>: Ziel-IP-Adressen, auf die zugegriffen werden soll.
      </li>
      <li>
<command>dstdomain</command>: Name der Ziel-Domain, auf deren Server
im Internet zugegriffen werden soll. Hier kann auch direkt
ein Server angegeben werden!
      </li>
      <li>
<command>dstdom_regex</command>: Wie <command>dstdomain</command>, zusätzlich können
<ref chapter="regex">Reguläre Ausdrücke</ref>
verwendet werden, um die Liste der Server zu erweitern.
      </li>
      <li>
<command>time</command>: Zur Festlegung bestimmter Zeitbereiche, in denen gesurft
werden darf.
      </li>
      <li>
<command>url_regex</command>: URLs können über Reguläre Ausdrücke definiert werden.
      </li>
      <li>
<command>urlpath_regex</command>: Der Pfad, also alles, außer dem Protokoll
(wie <strong>http://</strong>) und dem Rechnernamen (wie <strong>www.selflinux.org</strong>), wird mit
dem angegebenen Regulären Ausdruck verglichen.
      </li>
      <li>
<command>ident</command>: Vergleich der Namen, die von den Unix-Clients mit dem <command>identd</command>
übertragen werden, mit denen in der Liste. So kann eine
einfache Benutzerverwaltung genutzt werden. Den <command>identd</command> gibt
es auch für Windows als Programm oder als Dienst.
      </li>
      <li>
<command>external</command>: Einbinden eines externen Hilfsprogramms, das z. B.
ermöglicht, zur Benutzerverwaltung einen NT-Domänen-Kontroller
zu nutzen.
      </li>
     </ul>

     <textblock>
Weitere ACL-Typen stehen für spezielle Anwendungen des Squid zur
Verfügung, die nicht für die Benutzerverwaltung wichtig sind.
     </textblock>

     <textblock>
Werden mehrere Werte hinter dem ACL-Typ aufgelistet, braucht nur einer
der Werte zu passen, um das zugehörige <command>http_access</command> zu aktivieren
(OR-Logik, siehe <ref iref="Logik der Rechtevergabe">Logik der Rechtevergabe</ref>).
     </textblock>

     <textblock>
Zur besseren Übersicht können die aufzulistenden Werte auch in eine
eigene Datei ausgelagert werden.
Dort wird für jeden Eintrag eine eigene Zeile angelegt.
Die Datei muss Squid wie folgt bekanntgegeben werden:
     </textblock>

     <file>
      <content>
acl &lt;frei_definierbarer_Name&gt; &lt;acl-Typ&gt; "&lt;Pfad_zur_Datei&gt;"
      </content>
     </file>
    </section>

    <section>
     <heading>
Zugriffsrechte für die ACLs definieren
     </heading>

     <textblock>
Mit <command>http_access</command> wird in Kombination mit <command>allow</command> bzw.
<command>deny</command> ein Recht für die definierten ACL-Elemente festgelegt.
     </textblock>

     <textblock>
Die Syntax:
     </textblock>

     <file>
      <content>
http_access allow|deny &lt;acl-Name ...&gt;
      </content>
     </file>

     <textblock>
Das sieht zunächst sehr simpel aus. Einer definierten ACL wird über
<command>deny</command> oder <command>allow</command>" ein gewünschtes Recht zugewiesen,
so wie im Beispiel des Abschnittes
<ref iref="Squid-Konfiguration auf die Schnelle">Squid-Konfiguration auf die Schnelle</ref> gezeigt:
     </textblock>

     <file>
      <content>
acl allowed_hosts src 192.168.10.0/255.255.255.0
http_access allow allowed_hosts
      </content>
     </file>

     <textblock>
Komplexer wird es, wenn mehrere ACL-Namen in einer Zeile
aufgelistet sind. Dies bewirkt, dass alle aufgelisteten ACLs
zutreffen müssen, damit das <command>allow</command> oder <command>deny</command>" in Kraft treten kann.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
acl all            src    0/0
acl selflin        dstdom .selflinux.org
acl pcRestr        src    192.168.20.0/255.255.255.0
acl allowed_hosts  src    192.168.10.0/255.255.255.0

http_access allow selflin       pcRestr
http_access allow allowed_hosts
http_access deny  all
      </content>
     </file>

     <textblock>
Die Angabe der zwei ACL-Namen <strong>selflin</strong> und <strong>pcRestr</strong> nach dem ersten
<command>http_access</command> bewirkt, dass Rechner mit der IP <strong>192.168.20.*</strong> nur
auf SelfLinux-Seiten surfen dürfen.
Die <command>allowed_hosts</command> dürfen alles sehen, da diese nicht mit einer
zusätzlichen ACL in der <command>http_access</command>-Zeile eingeschränkt werden.
     </textblock>

     <textblock>
Hier ist gleich eine wichtige Eigenart des ACL-Typs <command>dstdom</command> zu
erkennen:
Der <strong>'.'</strong> vor dem Domainnamen sagt Squid, dass auch Subdomains in diese
ACL fallen, wie z. B. www.selflinux.org oder srv.sub.selflinux.org.
     </textblock>
    </section>

    <section>
     <heading>
Logik der Rechtevergabe
     </heading>

     <textblock>
Es ist sehr wichtig für das Berechtigungsmodell von Squid,
die OR/AND-Logik zu verstehen:
     </textblock>

     <ul>
      <li>
Alle Elemente eines ACL-Eintrags werden mit OR verknüpft.
      </li>
      <li>
Alle Elemente eines Access-Eintrags dagegen werden mit einem AND
verknüpft.
      </li>
     </ul>

     <textblock>
Noch ein Beispiel, das fatalerweise überhaupt keinen Zugriff
ermöglicht:
     </textblock>

     <file>
      <content>
acl wir src 192.168.10.0
acl ihr src 192.168.20.0
http_access allow wir ihr
      </content>
     </file>

     <textblock>
Hier würden Zugriffe dann erlaubt werden, wenn sich der Surfende
zugleich mit den beiden Quell-IPs an den Proxy wendet, was nicht
möglich ist. Somit werden keine Zugriffe mehr erlaubt.
     </textblock>

     <textblock>
Sollen dagegen beide IP-Adressen Zugriff erhalten, muss folgendes
eingetragen werden:
     </textblock>

     <file>
      <content>
acl wir src 192.168.10.0 192.168.20.0
http_access allow wir
      </content>
     </file>

     <textblock>
Ein weiterer wichtiger Punkt ist die Reihenfolge der <command>access</command>-Listen.
     </textblock>

     <textblock>
Ist erst einmal ein Zugriff erlaubt worden, kann er durch darunter
liegende Zeilen nicht wieder zurückgenommen werden.
     </textblock>

     <textblock>
Beispiel:
     </textblock>

     <file>
      <content>
acl selflin  dstdom .selflinux.org
acl verboten src    10.0.0.23
http_access allow selflin
http_access deny  verboten
      </content>
     </file>

     <textblock>
Obwohl <strong>10.0.0.23</strong> in der letzen Zeile alles verboten wird, kann
dieser PC die Seiten von SelfLinux sehen, da die Erlaubnis über dem
kompletten Verbot vergeben wurde.
     </textblock>
    </section>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Squid aus Quellen kompilieren
   </heading>

   <textblock>
Selbst kompilieren hat mehrere Vorteile:
   </textblock>

   <ol>
    <li>
Es können zusätzliche Funktionen aktiviert oder zur
Stabilitätserhöhung ungenutzte Funktionen deaktiviert werden
    </li>
    <li>
Die aktuellsten Versionen sind meist nur als Quellen verfügbar
    </li>
    <li>
Das kompilierte Programm ist optimal an die Umgebung
angepasst, wie z.B. Prozessortyp und Bibliotheken.
    </li>
   </ol>

   <textblock>
Der Nachteil ist, dass die Installation erheblich aufwendiger ist.
   </textblock>

   <section>
    <heading>
Kompilieren und Installation
    </heading>

    <textblock>
Zunächst sollten die neuesten Squid-Quellen geholt werden unter
<ref lang="en" url="http://www.squid-cache.org/">www.squid-cache.org</ref>
(am besten die jeweils aktuellste STABLE-Version wählen).
    </textblock>

    <textblock>
Anschließend sind diese auszupacken mit:
    </textblock>

    <shell>
     <root>
cd /usr/local/src
     </root>
     <root path="/usr/local/src">
tar xvjf squid-&lt;Version&gt;.tar.bz2
     </root>
    </shell>

    <textblock>
Mit dem <command>configure</command>-Kommando können Parameter übergeben werden, um
Squid den eigenen Anforderungen anzupassen. Die möglichen Parameter
sind zu erfahren mit:
    </textblock>

    <shell>
     <root>
cd squid-&lt;Version&gt;
     </root>
     <root>
./configure --help
     </root>
    </shell>

    <textblock>
Anschließend kann kompiliert und installiert werden.
    </textblock>

    <textblock>
Soll Squid beispielsweise mit
<ref iref="Squid in Windows-NT-Netz integrieren">Zugriffsmöglichkeiten auf eine Windows-NT-Domäne</ref>
installiert werden, kann der Aufruf von <command>configure</command> z. B.
folgendermaßen aussehen:
    </textblock>

    <shell>
     <root>
./configure  --enable-auth="ntlm,basic" --enable-external-acl-helpers="wbinfo_group"
     </root>
     <root>
make all
     </root>
     <root>
make install
     </root>
    </shell>
   </section>

   <section>
    <heading>
Konfiguration
    </heading>

    <textblock>
Die Konfigurationsdatei <path>squid.conf</path> liegt standardmäßig nach dem
Kompilieren unter <path>/usr/local/squid/etc/squid.conf</path>. Der Übersicht und
Einheitlichkeit halber sollte folgender Link erzeugt werden:
    </textblock>

    <shell>
     <root>
ln -s /usr/local/squid/etc/squid.conf /etc/squid.conf
     </root>
    </shell>

    <textblock>
Vor dem ersten Start ist die Cache-Verzeichnisstruktur und deren
Rechte anzulegen mit:
    </textblock>

    <shell>
     <root>
mkdir -p /usr/local/squid/var/cache
     </root>
     <root>
mkdir -p /usr/local/squid/var/logs
     </root>
     <root>
chown -R nobody /usr/local/squid/var/cache
     </root>
     <root>
chown -R nobody /usr/local/squid/var/logs
     </root>
     <root>
/usr/local/squid/sbin/squid -z
     </root>
    </shell>

    <textblock>
Die Konfiguration über die Datei <path>squid.conf</path> ist identisch mit der von
<ref chapter="software_installation" iref="RPM">RPM</ref>- oder
<ref chapter="software_installation" iref="Debian Paket Format">DEB</ref>-Paket-Installationen.
    </textblock>
   </section>

   <section>
    <heading>
Installation kontrollieren
    </heading>

    <textblock>
Der Squid kann im Debug-Modus gestartet werden, um mögliche Fehler
gleich auf dem Terminal zu sehen (siehe
<ref iref="Squid-Daemon starten">Squid-Daemon starten</ref>).
    </textblock>
   </section>

   <section>
    <heading>
Squid starten mit Startskript
    </heading>

    <textblock>
Läuft der Squid im Testlauf ohne Probleme, sollte ein Startskript
erstellt werden. Über dieses kann der Squid bei einem Neustart des
Systems automatisch hochgefahren werden.
    </textblock>

    <textblock>
Zu beachten ist, dass der Squid bei noch aktiven Verbindungen längere
Zeit braucht, bis er gestoppt ist. Deshalb ist hier für den Stop-Fall
eine Schleife einzubauen, die das Skript erst dann beendet, wenn der
Daemon wirklich gestorben ist, da ansonsten ein erneuter Start mit
Fehlern abgebrochen wird.
    </textblock>

    <file>
     <content>
      <![CDATA[
#!/bin/bash

squid=/usr/local/squid/sbin/squid
test -x $squid || exit 0

case "$1" in
start)
        echo "Starting squid"
        $squid -D -sYC
        sleep 1
        $0 status
;;
stop)
        echo "Stopping squid"
        $squid -k shutdown
        n=0
        while $squid -k check && [ $n -lt 120 ]; do
                sleep 1
                echo -n .
                n=`/usr/bin/expr $n + 1`
        done
        $0 status
;;
status)
        $squid -k check
        /bin/ps aux | /bin/grep squid | /bin/grep -v -e "status" -e "grep"
;;
reload)
        $squid -k reconfigure
;;
restart)
        $0 stop && $0 start
;;
*)
        echo "Usage: $0 {start|stop|reload|restart|status|}" >&2
;;
esac
      ]]>
     </content>
    </file>

    <textblock>
Dieses Skript ist als <path>/etc/init.d/squid</path> anzulegen und ausführbar
zu machen.
    </textblock>

    <textblock>
Um einen automatischen Start des Squid nach einem Neustart zu
erreichen, müssen die entsprechenden Links in den rc-Verzeichnissen
auf /etc/init.d/squid gesetzt werden. Da sich die einzelnen
Linux-Distributionen hier leider sehr unterscheiden, ist hierfür
kein einfaches Beispiel möglich.
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Squid in Windows-NT-Netz integrieren
   </heading>

   <section>
    <heading>
Funktionen für die Windows-NT-Benutzerverwaltung
    </heading>

    <textblock>
Der Squid ist flexibel, ausgereift und kostenlos, doch innerhalb
eines Windows-Netzes hatte er bis zur Version 2.4 zwei gravierende
Nachteile:
    </textblock>

    <ol>
     <li>
<strong>Doppelte Benutzerverwaltung</strong>:
Sollen User unterschiedliche Web-Zugriffsrechte bekommen, müssen diese
Nutzer dem Squid natürlich bekannt sein, d. h. es ist eine
Benutzerverwaltung notwendig. Diese musste bislang zusätzlich,
neben der Windows-Domänen-Benutzerverwaltung, betreut werden, was
einen erheblichen administrativen Mehraufwand bedeutete.
     </li>
     <li>
<strong>Verminderte Benutzerfreundlichkeit beim Surfen</strong>:
Eine transparente Authentifizierung durch den Internet Explorer (IE)
war nicht möglich, d.h. es musste für den Zugang Name und Passwort
in ein Browser-Fenster eingeben werden, das auch noch unabhängig
von dem der Windows-NT-Domäne ist.
     </li>
    </ol>

    <textblock>
Diese Nachteile sind mit der Squid-Version 2.5 bei entsprechender
Konfiguration behoben.
    </textblock>

    <textblock>
Das Squid- und das <ref url="http://samba.org">Samba-Team</ref>
schufen gemeinsam die Möglichkeit, die
Benutzerverwaltung einer Windows-NT-Domäne für Squid nutzen zu können.
Der Zugriff auf die Windows-Domäne wird dem Squid-Proxy mit Hilfe
neuer Helper-Module in Ergänzung zu Samba-Winbind ermöglicht.
    </textblock>

    <textblock>
Auch die Benutzerfreundlichkeit für den Surfenden ist mit der
MS-Konkurrenz gleichgezogen. Dabei nutzt der Squid die gleichen
Mechanismen (NTLM) wie ein MS-Proxy. Es ist mit dem IE keine
zusätzliche Authentifizierung mehr notwendig.
Mit allen anderen Browsern muss man sich authentifizieren,
und zwar mit dem Nutzernamen und Passwort des NT-Benutzers.
    </textblock>

    <textblock>
Die Arbeitserleichterung für Administratoren eines Windows-Netzes ist
enorm. Der neu angelegte User hat sofort die für ihn bestimmten
Rechte, wenn er nur der entsprechenden Windows-Gruppe hinzugefügt
wird. Da die User im Usermanager für NT normalerweise mit F8 von
einer Vorlage kopiert werden, ist dies kein Mehraufwand.
    </textblock>

    <textblock>
Gibt es Probleme mit fehlenden Rechten, reicht nun meist ein Blick in
den Usermanager, um diese zu kontrollieren.
    </textblock>

    <textblock>
Die Installation und Einrichtung mit der genannten Zielsetzung ist
nicht trivial, sollte aber mit geringen Unix-Grundkenntnissen und
dieser Anleitung möglich sein.
Leider ist es meist unumgänglich, die Programme <command>samba</command>
und <command>squid</command> selbst zu kompilieren.
Vorhandene Binaries der Linux-Distributionen sind nicht
mit den nötigen Parametern übersetzt und oft nicht aktuell genug.
    </textblock>
   </section>

   <section>
    <heading>
Samba mit Winbind
    </heading>

    <section>
     <heading>
Installation
     </heading>

     <textblock>
Es müssen Entwicklertools wie <ref chapter="make">make</ref> und <command>gcc</command> installiert sein.
Die folgenden Ausführungen beziehen sich auf die Samba-Version 3.0.*.
     </textblock>

     <textblock>
Nach dem Download der <ref url="http://samba.org">Quellen</ref>
sollten diese unter <path>/usr/local/src/</path>
ausgepackt werden. Samba ist zu übersetzen und zu installieren mit:
     </textblock>

     <shell>
      <root>
cd /usr/local/src/samba-&lt;Version&gt;/source
      </root>
      <root>
./configure --with-winbind
      </root>
      <root>
make
      </root>
      <root>
make install
      </root>
     </shell>
    </section>

    <section>
     <heading>
Konfiguration von Samba/winbind
     </heading>

     <textblock>
Als erstes ist eine <command>smb.conf</command> aus dem Quelltest in das richtige
Verzeichnis zu kopieren:
     </textblock>

     <shell>
      <root>
cp /usr/local/src/samba-&lt;Version&gt;/examples/smb.conf.default
      </root>
     </shell>

     <textblock>
Um die Konfigurationsdatei leichter zu finden, sollte ein Link in das
Verzeichnis <path>/etc/</path> erstellt werden mit:
     </textblock>

     <shell>
      <root>
ln -s /usr/local/samba/lib/smb.conf /etc/smb.conf
      </root>
     </shell>

     <textblock>
Nun sollte diese Datei folgendermaßen angepasst werden:
     </textblock>

     <file>
      <content>
workgroup = &lt;NT-Domänen-Name&gt;
security = domain
# hier die Domain Controller des Standortes eintragen
password server = &lt;dc1&gt; &lt;dc2&gt;
wins support = no
# Hier die WINS-Server der Standorte eintragen
wins server = &lt;IP_des_WINS-Servers&gt;
max log size = 10000
local master = no
winbind enum users = yes
winbind enum groups = yes
winbind use default domain = yes
idmap uid = 10000-20000
idmap gid = 10000-20000
template shell = /bin/false
      </content>
     </file>

     <textblock>
Unter <strong>workgroup</strong> ist der eigene NT-Domänen-Name einzusetzen.
Als <strong>password server</strong> muss mindestens ein Domänen-Controller angegeben
werden.
     </textblock>

     <textblock>
Nun kann der Samba-Rechner in die Windows-NT-Domäne aufgenommen
werden mit:
     </textblock>

     <shell>
      <root>
/usr/local/samba/bin/net rpc join -S &lt;PDC&gt; -U &lt;Administrator&gt;
      </root>
     </shell>
    </section>

    <section>
     <heading>
Installation testen
     </heading>

     <textblock>
Nun können die Dienste von Samba gestartet werden:
     </textblock>

     <shell>
      <root>
/usr/local/samba/bin/nmbd -D
      </root>
      <root>
/usr/local/samba/bin/smbd -D
      </root>
      <root>
/usr/local/samba/bin/winbindd -B
      </root>
     </shell>

     <textblock>
Um zu sehen, ob diese auch laufen, listet folgendes Kommando die
gestarteten Services auf:
     </textblock>

     <shell>
      <root>
ps aux | egrep "(mbd|winbind)"
      </root>
     </shell>

     <textblock>
Die Anbindung des Samba-Servers an die
Windows-Domänen-Benutzerverwaltung kann getestet werden mit:
     </textblock>

     <shell>
      <root>
wbinfo -u
      </root>
     </shell>

     <textblock>
Wenn Winbind korrekt arbeitet, sollten alle User der NT-Domänen
ausgegeben werden.
     </textblock>
    </section>
   </section>

   <section>
    <heading>
Squid
    </heading>

    <section>
     <heading>
Kompilierung, Installation und Konfiguration
     </heading>

     <textblock>
Die Kompilierung und Installation ist im Abschnitt
<ref iref="Squid aus Quellen kompilieren">Squid aus Quellen kompilieren</ref>
abgehandelt und mit einem passenden Beispiel erklärt worden.
     </textblock>

     <textblock>
Zur Nutzung von NT-Gruppen muss des Weiteren sichergestellt werden,
dass ein <command>perl</command> ab der Version 5.8 installiert ist.
     </textblock>

     <textblock>
Die spezifischen Einträge in der <path>/etc/squid.conf</path> sind:
     </textblock>

     <file>
      <content>
# Einbindung der neuen ACL-Helper Schnittstelle, hier NT-Domänen
external_acl_type NT_global_group children=10 ttl=900 %LOGIN /usr/local/squid/libexec/wbinfo_group.pl

auth_param ntlm program /usr/local/samba/bin/ntlm_auth --helper-protocol=squid-2.5-ntlmssp
auth_param ntlm children 80
auth_param ntlm max_challenge_reuses 1
auth_param ntlm max_challenge_lifetime 5 minutes
auth_param basic program /usr/local/samba/bin/ntlm_auth --helper-protocol=squid-2.5-basic
auth_param basic children 50
auth_param basic realm squid proxy-caching web server
auth_param basic credentialsttl 2 hours
# acl &lt;FreiDefinierbarerName&gt; &lt;aclTyp&gt; &lt;Definition&gt;
acl ProxyUsers external NT_global_group &lt;NT-Gruppen-Name&gt;
acl AuthorizedUsers proxy_auth REQUIRED
# Beispiel für die Rechtevergabe:
acl selflinux dstdomain .selflinux.org
# Vollzugriff für diese Gruppe
http_access allow AuthorizedUsers ProxyUsers
# Dies hätte nur Zugriff auf die Selflinux-Seiten erlaubt:
#http_access allow AuthorizedUsers ProxyUsers selflinux
      </content>
     </file>

     <textblock>
In der Squid-Dokumentation zu NTLM wird eine Anzahl von 5
Kind-Prozessen vorgeschlagen. Dies bewirkte in der vom Autor
betreuten Umgebung <strong>aufpoppende</strong> Anmelde-Fenster.
Deshalb scheint es empfehlenswert zu sein, reichlich Kind-Prozesse
starten zu lassen.
Zur Beschleunigung können zusätzlich die beiden challenge-Werte
höher gesetzt werden als vorgegeben. Diese legen zusammen die
Gültigkeitsdauer einer Anfrage an die Windows-Domänen-Controller fest.
     </textblock>

     <textblock>
Wer Hilfe zu den Funktionen der weiteren Parameter sucht, findet diese
ausführlich in der <path>/etc/squid.conf</path> beschrieben.
     </textblock>

     <textblock>
Nun muss noch der Squid-Daemon folgende Berechtigung bekommen:
     </textblock>

     <shell>
      <root>
chgrp -R nogroup /usr/local/samba/var/locks/winbindd_privileged/
      </root>
     </shell>

     <textblock>
Um einen gültigen Computeraccount in der Domain zu halten, sollte
folgender <ref chapter="cron">Cronjob</ref> hinzugefügt werden:
     </textblock>

     <file>
      <content>
0 2 * * * /usr/local/samba/bin/net rpc changetrustpw
      </content>
     </file>
    </section>

    <section>
     <heading>
Installation prüfen
     </heading>

     <textblock>
Zunächst sollte die Anbindung an die NT-Domäne getestet werden. Nach
der Eingabe von
     </textblock>

     <shell>
      <root>
/usr/local/samba/bin/ntlm_auth --helper-protocol=squid-2.5-basic
      </root>
     </shell>

     <textblock>
wartet das Programm <command>wb_auth</command> auf die Eingabe eines gültigen
NT-Accounts in Form von
     </textblock>

     <shell>
      <input>
&lt;NT-Domänen-Name&gt;\&lt;Accout&gt; &lt;Password&gt;
      </input>
     </shell>

     <textblock>
wie z.B.:
     </textblock>

     <shell>
      <input>
Domain\joern geheim
      </input>
     </shell>

     <textblock>
Die Ausgabe muss mit einem <strong>OK</strong> abschließen.
     </textblock>

     <textblock>
Nach dem Anlegen der Cache-Verzeichnisstruktur kann der Squid
Debug-Modus gestartet und mögliche Fehler behoben werden, siehe dazu
<ref iref="Squid-Daemon starten">Squid-Daemon starten</ref>.
     </textblock>
    </section>

    <section>
     <heading>
Squid starten
     </heading>

     <textblock>
Nun muss ein Startskript erstellt und mit dem
gewünschten Runlevel verlinkt werden. Siehe hierzu
<ref iref="Squid starten mit Startskript">Squid starten mit Startskript</ref>
     </textblock>
    </section>

    <section>
     <heading>
Zugriffsrechte auf Internet-Seiten setzen
     </heading>

     <textblock>
Für die User-Verwaltung bleiben folgende Aufgaben:
     </textblock>

     <section>
      <heading>
Squid-Rechte
      </heading>

      <textblock>
Für jede globale Windows-NT-Gruppe muss eine ACL in der
<path>/etc/squid.conf</path> erstellt werden.
Dort wird das externe Programm, definiert über den oben angegebenen
<command>external_acl_type</command>", eingebunden und damit eine Verknüpfung von
NT-Gruppen mit Squid-ACL-Namen erreicht:
      </textblock>

      <file>
       <content>
acl &lt;Frei_definierbarer_Name&gt; external NT_global_group &lt;WinNT-GruppenName&gt;
       </content>
      </file>

      <textblock>
Beispiel:
      </textblock>

      <file>
       <content>
acl verwaltung  external NT_global_group verwaltung
       </content>
      </file>

      <textblock>
Eine weitere ACL ist für die Seiten zu erstellen, die von der Gruppe
gesehen werden sollen:
      </textblock>

      <file>
       <content>
acl &lt;GruppenName&gt; dstdomain &lt;.Dns-Domäne1&gt; &lt;.Dns-Domäne2&gt;  ...
       </content>
      </file>

      <textblock>
Beispiel:
      </textblock>

      <file>
       <content>
acl verwaltung_dstdom dstdomain .selflinux.org .intranet.de
       </content>
      </file>

      <textblock>
Als letztes sind für die ACLs die Rechte festzusetzen:
      </textblock>

      <file>
       <content>
http_access allow AuthorizedUsers &lt;ACL-GruppenName&gt; &lt;ACL-Zieldomänen-Name&gt;
       </content>
      </file>

      <textblock>
Beispiel:
      </textblock>

      <file>
       <content>
http_access allow AuthorizedUsers verwaltung verwaltung_dstdom
       </content>
      </file>

      <textblock>
Weitere Informationen zur Rechtevergabe siehe unter
<ref iref="Rechtevergabe unter Squid im Detail">Rechtevergabe unter Squid im Detail</ref>.
      </textblock>
     </section>

     <section>
      <heading>
NT-Domänen-Rechte
      </heading>

      <textblock>
Die Surfer müssen hier nur in die globalen Gruppen aufgenommen
werden, die auf dem Squid mit den entsprechenden Gruppen verknüpft
sind.
      </textblock>
     </section>
    </section>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Browser-Proxy-Einstellungen automatisieren und optimieren
   </heading>

   <textblock>
Netscape hat für seinen Browser eine Möglichkeit entwickelt, über
Javascript die Proxy-Einstellungen des Browsers zu konfigurieren.
Inzwischen haben alle bekannten Browser diese Fähigkeit
integriert.
   </textblock>

   <textblock>
Über ein solches Skript kann festgelegt werden, auf welcher Adresse
und über welchen Port der Proxy seinen Dienst zur Verfügung stellt.
Zusätzlich kann definiert werden, welche IPs und URLs über den Proxy
zu gehen haben und welche dagegen direkt an einen Web- oder FTP-Server
weitergeleitet werden.
   </textblock>

   <textblock>
Worin besteht nun der Vorteil, ein derartiges Skript zu nutzen,
gegenüber dem direkten Eintragen des Proxies in der
Browser-Konfiguration?
   </textblock>

   <ul>
    <li>
<strong>Erhöhte Flexibilität:</strong>
Wenn der Proxy die IP oder den Port wechselt, sich die Einträge für
direkten Zugriff ändern, reicht ein Eintrag in dem zentralen Skript.
Ansonsten müssten zur Änderung alle Client-PCs angefasst werden.
    </li>
    <li>
<strong>Erhöhte Ausfall-Sicherheit:</strong>
Sind mehrere Proxies vorhanden, können alle eingetragen werden.
Ist der erste in der Liste nicht erreichbar, wird der
zweite genommen u. s. w. Es kann sogar eingetragen werden, dass,
wenn kein Proxy zur Verfügung steht, der Browser direkt ins Internet
geht (wenn dies netzwerktechnisch erlaubt sein sollte).
Soll der Proxy dagegen direkt in die Browser-Konfiguration
eingetragen werden, ist nur <strong>ein</strong> einziger Proxy-Eintrag möglich.
    </li>
    <li>
<strong>Steuerung des Traffic:</strong>
Sind die Internet-Nutzer über mehrere Standorte verteilt, kann
über die Feststellung, aus welchem Netz er zugreift, der optimale
Proxy für ihn zugewiesen werden.
    </li>
    <li>
<strong>Erleichterung bei Wartung:</strong>
Schnelle Reaktion bei Ausfall eines Proxys ist durch einfache
Konfiguration des Proxy-Skriptes möglich. Bei Wartungsarbeiten kann
vorübergehend einfach ein anderer Proxy zugewiesen werden.
    </li>
   </ul>

   <textblock>
Der Pfad zu dem Skript ist in der Browser-Konfiguration einzutragen.
Dies kann manuell oder zentral und automatisiert über zu kopierende
Konfigurations-Dateien oder unter Windows NT/2000/XP über die
Systemrichtlinien/Policy erfolgen.
   </textblock>

   <section>
    <heading>
Automatische Proxy-Konfiguration
    </heading>

    <textblock>
Es ist nicht nötig, Javascript programmieren zu können, um die
Möglichkeiten der Auto-Konfiguration zu nutzen.
Es sollte reichen, die hier vorgestellten Beispiele den eigenen
Netzen anzupassen, d.h. die Domains und IPs mit den eigenen zu
ersetzen.
    </textblock>

    <section>
     <heading>
Eigene Server direkt ansprechen
     </heading>

     <textblock>
Sollen sich die Clients direkt, ohne Proxy als Bindeglied
dazwischen, an die eigenen Web-Server wenden, kann dies über den
eigenen Domain-Namen wie im folgenden Skript umgesetzt werden:
     </textblock>

     <file>
      <content>
function FindProxyForURL(url, host)
{
  if (dnsDomainIs(host, ".selflinux.org"))
    return "DIRECT";
  else
    return "PROXY wwwproxy.selflinux.org:3128";
}
      </content>
     </file>

     <textblock>
Die Zahl hinter dem Proxy-Namen legt den Port des Proxies fest.
     </textblock>

     <textblock>
Eine andere Möglichkeit besteht in der Angabe der Netzadresse, welche
direkt, ohne Proxy, angesprochen werden soll:
     </textblock>

     <file>
      <content>
function FindProxyForURL(url, host)
{
  if (isInNet(host, "192.168.10.0", "255.255.255.0"))
    return "DIRECT";
  else
    return "PROXY wwwproxy.selflinux.org:3128";
}
      </content>
     </file>
    </section>

    <section>
     <heading>
Proxy-Auswahl für verschiedene Standorte automatisieren
     </heading>

     <textblock>
Sind mehrere Standorte mit relativ langsamen Standleitungen verbunden,
ist der Aufbau eines Cache-Verbundes sinnvoll. Dafür werden mehrere
Squid-Proxies aufgesetzt und sinnvoll miteinander gekoppelt.
     </textblock>

     <textblock>
Für einen derartigen Proxy-Verbund ist es wichtig, den
Internet-Nutzern immer den Proxy vor Ort zuzuweisen, um die
in dem Standort zwischengespeicherten Seiten nutzen zu können.
Dadurch wird eine Standleitung oder auch ein VPN entlastet.
     </textblock>

     <textblock>
Die URL, unter welcher das Skript abgelegt ist, gilt für alle
Standorte. Besonders Mitarbeiter, welche oft die
Standorte wechseln, werden dies sehr begrüßen.
     </textblock>

     <textblock>
Das Konfigurations-Skript muss nun feststellen können, an welchem
Standort sich der Internet-Nutzer befindet.
Da Netze verschiedener Standorte jeweils eigene IP-Bereiche haben
sollten, kann dies über die Abfrage der Quell-IP erfolgen.
Netscape hatte leider nicht vorgesehen, in der Konfigurationsdatei
nach der Quell-IP fragen zu können. Deshalb hier eine Lösung über
PHP, die diese Funktion hinzufügt. Der <ref chapter="apache">Webserver</ref>, der das Auto-Skript
beherbergt, muss PHP installiert haben.
     </textblock>

     <file>
      <content>
       <![CDATA[
<?php
header("Content-type: application/x-ns-proxy-autoconfig");
if (preg_match("/192\.168\.85/", $REMOTE_ADDR)) {
  $adrr = "PROXY wwwproxy.selflinux.org:3128; PROXY wwwproxy2.selflinux.org:3128";
}
if (preg_match("/192\.168\.75\./", $REMOTE_ADDR)) {
  $adrr = "PROXY 10.20.20.1:3128; PROXY wwwproxy.selflinux.org:3128";
}
?>
       ]]>
      </content>
     </file>

     <file>
      <content>
function FindProxyForURL(url, host)
{
if (isPlainHostName(host) ||
  dnsDomainIs(host, ".selflinux.org") ||
  dnsDomainIs(host, ".partnernetz.de") ||
  isInNet(host, "192.168.85.0", "255.255.255.0") ||
  isInNet(host, "172.20.20.80", "255.255.255.255") ||
  isInNet(host, "192.168.75.0", "255.255.255.0")
    return "DIRECT";
  else
  return "<?php echo $adrr; ?>";
}
      </content>
     </file>

     <textblock>
Wird also z.B. von einem <strong>192.168.75.*</strong> Netz zugegriffen, wird der
Proxy <strong>10.20.20.1</strong> zugewiesen. Wenn der nicht verfügbar ist, wird
<strong>wwwproxy.selflinux.org</strong> genutzt. Und das, ohne dass es der Anwender
bemerkt.
     </textblock>
    </section>
   </section>
  </section>
 </split>
</chapter>
