<?xml version="1.0" encoding="iso-8859-1"?>
<chapter>
 <title>Das Partitionieren</title>

 <author>
  <name>Arnulf Pelzer</name>
  <mailto>webmaster@arnulfpelzer.de</mailto>
 </author>

 <layout>
  <name>Matthias Hagedorn</name>
  <mailto>matthias.hagedorn@selflinux.org</mailto>
 </layout>

 <license>GPL</license>

 <index>partitionieren</index>

 <split>
  <section>
   <heading>
Das Partitionieren
   </heading>

   <textblock>
Um Ordner und Dateien auf Festplatten abzuspeichern oder zu lesen
ist es notwendig, die Festplatte in einen Zustand zu versetzen, der
dies ermöglicht. Der erste Schritt ist das Partitionieren, der zweite
das Formatieren. Dieser Text soll Ihnen helfen mit dieser Hürde umzugehen.
Das Partitionieren ist das Aufteilen einer Festplatte in mehrere
Teile, sogenannte Partitionen. Diese sind voneinander unabhbängig und
können verschiedene Dateisysteme enthalten. Partitionen
entsprichen Schubladen in einem Schrank. Zieht man eine heraus und
nimmt etwas heraus, leert sie oder ändert man den Inhalt werden die
anderen Schubladen davon nicht betroffen.
Bei PCs gibt das PC-BIOS (<strong>Basic Input Output System</strong>)
vor, wieviele Partitionen verwendet werden dürfen.
Für PC-Festplatten sind die eigentlichen Partitionen <strong>Primäre Partitionen</strong>,
davon können Sie aber nur vier anlegen. Um diese
Einschränkung zu umgehen, wurden erweiterte (extended) Partitionen
eingeführt. Eine primäre Partition kann als erweiterte Partition in
mehrere logische Partitionen unterteilt werden.
Vom <ref lang="de" url="http://de.wikipedia.org/wiki/BIOS">BIOS</ref>
gibt es keine Beschränkungen für die Anzahl logischer
Partitionen. Es darf aber nur eine erweiterte Partition pro Festplatte
existieren. Linux limitiert die Anzahl der Partitionen pro IDE-Festplatte
auf 63 Partitionen, drei benutzbar als primäre und 60 als logische
Partitionen. Bei SCSI-Festplatten 15, drei benutzbar als primäre und
zwölf als logische Partitionen.
    </textblock>
   
   <textblock>
Bei älternen PCs oder BIOS-Versionen sei darauf hingewiesen, dass die
<strong>Boot</strong>-Partition, jene die den Kernel enthält, innerhalb der
ersten 1024 Zylinder liegen muss. Da, in der Regel, die <strong>Boot</strong>
und die <strong>Root</strong> Partition identisch sind, müssen Sie darauf
achten das die <strong>Root</strong>-Partition innerhalb der ersten 1024
Zylinder der Festplatte untergebracht ist.
   </textblock>

   <textblock>
Bei neueren BIOS-Versionen die <strong>Enhanced Disk Drive Support</strong> verwenden
gibt es diese Einschränkungen nicht mehr. <command>lilo</command>, <command>grub</command> und andere
<ref lang="de" url="http://de.wikipedia.org/wiki/Bootmanager">Bootmanager</ref>
greifen über das BIOS auf int 0x13 (Unterstützung für
grosse Festplatten) um den <ref chapter="kernel">Kernel</ref> in den
Speicher zu laden. Sobald Linux gestartet ist, wird nicht mehr auf das BIOS
zurückgegriffen, da Linux eigene Routinen für den Festplattenzugriff verwendet.
GNU/Linux Systeme sollten den <ref chapter="verzeichnisse_unter_linux">Filesystem Hierarchy Standard</ref> (FHS)
unterstützen, dies ermöglicht es dem Nutzer Dateien an bestimmten
Orten im Dateisystem zu finden. Das Root Verzeichnis wird durch einen
einfachen Schrägstrich - slash (<path>/</path>) - dargestellt.
   </textblock>

   <table>
    <pdf-column width="50"/>
    <pdf-column/>
    <tr>
     <td><path>/</path></td>
     <td>Wurzel-Verzeichnis</td>
    </tr>
    <tr>
     <td><path>/bin</path></td>
     <td>wesentliche Programme</td>
    </tr>
    <tr>
     <td><path>/boot</path></td>
     <td>statische Dateien des Bootmanagers</td>
    </tr>
    <tr>
     <td><path>/dev</path></td>
     <td>Schnittstellen zu Geräten</td>
    </tr>
    <tr>
     <td><path>/etc</path></td>
     <td>Rechnerabhängige Konfigurationsdateien</td>
    </tr>
    <tr>
     <td><path>/home</path></td>
     <td>Heimatverzeichnisse der Benutzer</td>
    </tr>
    <tr>
     <td><path>/lib</path></td>
     <td>Wesentliche Systembibliotheken</td>
    </tr>
    <tr>
     <td><path>/mnt</path></td>
     <td>Einhänge Punkte für temporäre Dateisysteme</td>
    </tr>
    <tr>
     <td><path>/proc</path></td>
     <td>Virtuelles Verzeichnis für Systeminformationen</td>
    </tr>
    <tr>
     <td><path>/sys</path></td>
     <td>Virtuelles Verzeichnis für Systeminformationen</td>
    </tr>
    <tr>
     <td><path>/root</path></td>
     <td>Heimatverzeichnis des Systemadministrators (root)</td>
    </tr>
    <tr>
     <td><path>/sbin</path></td>
     <td>wesentliche Systemprogramme</td>
    </tr>
    <tr>
     <td><path>/tmp</path></td>
     <td>temporäre Dateien</td>
    </tr>
    <tr>
     <td><path>/usr</path></td>
     <td>sekundäre Dateisystemhirarchie</td>
    </tr>
    <tr>
     <td><path>/var</path></td>
     <td>Veränderliche Dateien</td>
    </tr>
    <tr>
     <td><path>/pt</path></td>
     <td>zusätzliche Software Pakete</td>
    </tr>
   </table>

   <textblock>
Eine weitere Partition, die in vielen GNU/Linux Systemen zu finden ist,
nennt man <strong>swap</strong>. Diese Partition dient dazu Speicherbereiche
des Hauptspeichers auszulagern, um weitere Programme auszuführen oder
ausgeführten Programmen mehr als den im System vorhandenen Speicher
zugänglich zu machen. Diese Funktion ist bei Rechnern mit wenig Hauptspeicher
sehr von Vorteil, da es ermöglicht <ref lang="de" url="http://de.openoffice.org/">OpenOffice</ref>
oder <ref lang="de" url="http://www.kde.de">KDE</ref> zu starten ohne
eigentlich den notwendigen Speicher dafür zur Verfügung zu haben. Es
ist aber nur eingeschränkt sinnvoll, da durch das Auslagern sehr viel Zeit
vergeht und ein zügiges Arbeiten nicht möglich ist.
   </textblock>

   <textblock>
Auf meinen privaten Rechnern mit 512 MB Ram und jeweils 1024MB
<strong>swap</strong>-Partition wird sehr selten der
<strong>swap</strong>-Bereich der Festplatte angefordert.
   </textblock>

   <textblock>
Bei Rechnern mit anderen Aufgaben kann dies aber ganz anders
aussehen. Sie sollten aber immer eine <strong>swap</strong> Partition anlegen,
da dies nur von Vorteil sein kann.
   </textblock>

   <textblock>
Ein GNU/Linux System braucht nur eine Partition um lauffähig zu sein.
   </textblock>
   
   <textblock>
Auf meinem Laptop sieht die Partitionierung so aus:
   </textblock>

   <shell>
    <output>
Platte /dev/hda: 30.0 GByte, 30005821440 Byte
255 Köpfe, 63 Sektoren/Spuren, 3648 Zylinder
Einheiten = Zylinder von 16065 × 512 = 8225280 Bytes

    Gerät boot.     Anfang        Ende     Blöcke   Id  System
/dev/hda1               1        1721    13823901   83  Linux
/dev/hda2            1722        1848     1020127+  82  Linux swap 
/dev/hda3            1849        3647    14450467+  83  Linux
    </output>
   </shell>

   <shell>
    <output>
/dev/hda1 ist die boot und root Partition
/dev/hda2 ist die swap Partition
/dev/hda3 ist die home Partition
    </output>
   </shell>

   <textblock>
Da es zu jeder Aufgabe für einen Computer verschiedene
Partitionierungs-Philosophien gibt, masse ich mir hier keine
Empfehlung an.
   </textblock>
  </section>
 </split>

 <split>
  <section>
   <heading>
Programme zum Partitionieren
   </heading>

   <textblock>
Es gibt unter GNU/Linux verschiedene Werkzeuge, um Festplatten zu
partitionieren. <command>fdisk</command>, <command>parted</command> und
die hier vorgestellten Programme <command>cfdisk</command> und
<command>qtparted</command>.
   </textblock>

   <section>
    <heading>
Partitionieren mit cfdisk
    </heading>

    <textblock>
Auf diesem Screenshot sehen Sie <command>cfdisk</command> mit einer leeren
Festplatte, bereit zum Partitionieren.
    </textblock>

    <image height="200">
     <title>cfdisk mit leeren Festplatte</title>
     <filename>cfdisk-leere-festplatte.png</filename>
    </image>

    <textblock>
Der obere Teil des Bildschirms zeigt die Daten der Festplatte, der
mittlere Teil die noch nicht vorhandenen Partitionen und der untere Teil die
Auswahlmöglichkeiten von <command>cfdisk</command> an.
    </textblock>

    <textblock>
Im nächsten Schritt gehen wir auf <command>Neue</command> und erstellen eine
primäre Partition mit 40 Gigabyte.
    </textblock>

    <image height="200">
     <title>Erstellen einer primären Partition mit 40 Gigabyte</title>
     <filename>cfdisk-40gig-eintragen.png</filename>
    </image>

    <textblock>
Nach dem Bestätigen mit der <command>Entertaste</command> sehen Sie Ihre
Partition nun im mittleren Bildschirmabschnitt.
    </textblock>

    <image height="200">
     <title>Eingetragene 40 Gigabyte</title>
     <filename>cfdisk-eingetragenene-40gig.png</filename>
    </image>

    <textblock>
Mit der Pfeil nach unten Taste kommen Sie wieder auf den
unpartitionierten Bereich der Festplatte.
Im nächsten Schritt erstellen wir eine 1 GB grosse Partition, die
als <strong>swap</strong> Speicher genutzt werden soll.
    </textblock>

    <image height="200">
     <title>swap-Speicher</title>
     <filename>cfdisk-swap.png</filename>
    </image>

    <textblock>
Nun gehen wir auf <command>Typ</command> und wählen Typ
<strong>82 Linux swap</strong> aus. Den Rest der
Festplatte wird wieder wie weiter oben beschriebenn als primäre
Partition verfügbar gemacht. Die Bildschirmausgabe sollte nun wie
folgt aussehen, bevor Sie mit dem Schreiben der
Partitionierungstabelle die Partitionierung übernehmen.
    </textblock>

    <image height="200">
     <title>Geamtliste</title>
     <filename>cfdisk-bevor-schreiben.png</filename>
    </image>

    <textblock>
In diesem Beispiel haben wir nun eine <path>/</path>(Root/Boot) eine
<strong>swap</strong> und eine <path>/home</path> Partition angelegt, so wie
sie von den meisten GNU/LINUX Installatinen unterstützt werden. Um genau zu
sein:
    </textblock>

    <textblock>
/dev/sda1 = Root/Boot Partition 40GB<br/>
/dev/sda2 = swap Partition       1GB<br/>
/dev/sda3 = Home Partition      39GB<br/>
    </textblock>
   </section>

   <section>
    <heading>
Partitionieren mit qtparted
    </heading>

    <textblock>
<command>Qtparted</command> hat den Vorteil, dass es zusätzlich noch bestehende
<strong>FAT</strong>, <strong>FAT32</strong> und <strong>NTFS</strong>
Partitionen bearbeiten kann, dies machen Sie natürlich auf
eigene Gefahr. Bevor Sie mit <command>qtparted</command> Windows Partitionen
bearbeiten können, sollten Sie <command>defrag</command> ausführen. Ein
<ref chapter="backups">Backup</ref> ist bei solchen
Dateibewegungen immer anzuraten. Der Autor dieses Textes hat keine
der oben genannten Dateisysteme und kann deshalb nicht auf die
genannten Fähigkeiten von <command>qtparted</command> eingehen.
Nun wird hier auch wieder nach dem obigen in Kapitel
<ref iref="Partitionieren mit cfdisk">Partitionieren mit cfdisk</ref>
genannten Schema das Partitionieren mit <command>qtparted</command>
vorgenommen.
    </textblock>

    <image height="150">
     <title>qtparted mit leeren Festplatte</title>
     <filename>qtparted-leere-festplatte.png</filename>
    </image>

    <textblock>
Wie Sie sehen ist <command>qtparted</command> eine in
<ref lang="en" url="http://www.trolltech.com">qt</ref> geschriebene grafische
Anwendung. Die Aufteilung der Oberfläche ist ein wenig anders als in
<command>cfdisk</command> aber deshalb nicht weniger übersichtlich.
Im linken oberen Fenster unter der Menüleiste sehen Sie die im Rechner
installierten Festplatten, darunter Informationen über die ausgewählte
Festplatte. Im rechten Bereich des Fensters den Arbeitsbereich. Durch
Anklicken der Festplatte im rechten Fenster können sie nun Partitionen anlegen.
    </textblock>

    <image height="150">
     <title> </title>
     <filename>qtparted-bevor-schreiben.png</filename>
    </image>

    <textblock>
Dies ist die gleiche Partitionsweise wie bei dem <command>cfdisk</command> Beispiel.
    </textblock>

    <textblock>
Über <command>Datei</command>-<command>Durchführen</command> übernehmen Sie
die gemachten Einstellungen. <command>qtparted</command> formatiert in diesem
Schritt auch das eingetragene Dateisystem. Die möglichen Dateisysteme werden
im nächsten <ref iref="Formatieren der Festplatte">Kapitel</ref> vorgestellt.
    </textblock>

    <image height="150">
     <title>Sicherheitswarnung</title>
     <filename>qtparted-sicherheitswarnung.png</filename>
    </image>

    <textblock>
Beachten Sie hier auch wieder die Warnung bei der Übernahme der
Änderungen!
    </textblock>
   </section>
  </section>
 </split>

 <split>
  <section>
   <heading>
Formatieren der Festplatte
   </heading>

   <textblock>
Um mit den erstellten Partitionen arbeiten zu können, müssen Sie die
Festplatte noch mit einem Dateisystem versehen. Bei einem GNU/Linux
System können Sie folgende Dateisysteme anlegen:
   </textblock>

   <ul>
    <li>
<ref iref="Ext2 und Ext3" chapter="dateisysteme_journaling">ext2</ref><br/>
ist das erprobte und wahre Linux Dateisystem. Es unterstützt aber kein
Journaling, was bedeutet, dass routinemäßige Überprüfungen des Dateisystems
beim Starten sehr zeitaufwändig sein können. Es gibt mittlerweile eine
Auswahl an Dateisystemen mit Journaling neuerer Generation, die die
Konsistenzchecks sehr schnell erledigen und dadurch im Vergleich den
Dateisystemen ohne Journal vorzuziehen sind. Dateisysteme mit Journaling
verhindern lange Verzögerungen beim Starten, wenn sich das Dateisystem in
einem inkonsistenten Zustand befindet.
    </li>
    <li>
<ref iref="Ext2 und Ext3" chapter="dateisysteme_journaling">ext3</ref><br/> 
ist die um Journaling erweiterte Version des <strong>ext2</strong> Dateisystems,
das Metadata Journaling für schnelle Wiederherstellung sowie andere verbesserte
Journaling Modi wie <strong>full data</strong> und <strong>ordered data</strong>
Jornaling unterstützt. <path>ext3</path> ist ein sehr gutes und verlässliches
Dateisystem. Kurz gesagt: <path>ext3</path> ist ein universelles Dateisystem
für den alltäglichen Einsatz.
    </li>
    <li>
<ref iref="ReiserFS" chapter="dateisysteme_journaling">ReiserFS</ref><br/> 
ist ein B*-tree basierendes Dateisystem mit einer guten Performance
und überholt sowohl <strong>ext2</strong> und <strong>ext3</strong> im Umgang mit
kleinen Dateien (Dateien kleiner als 4k) oftmals mit einem Faktor von 10-15.
ReiserFS skaliert extrem gut und hat Metadata Journaling. Seit Kernel
2.4.18 ist <strong>ReiserFS</strong> im stabilen Kernel enthalten und sowohl
als Dateisystem für generelle Anwendungen, als auch für extreme Fälle wie
große Dateisysteme, den Gebrauch mit vielen kleinen Dateien und den Gebrauch
mit sehr großen Dateien und Verzeichnissen mit tausenden von Dateien brauchbar.
    </li>
    <li>
<strong>Reiser4</strong><br/>
ist die neuste Variante des <strong>ReiserFS</strong>, es arbeitet besser mit
großen Dateien zusammen als <strong>ReiserFS</strong>.
    </li>
    <li>
<ref iref="SGI-XFS" chapter="dateisysteme_journaling">XFS</ref> 
ist ein Dateisytem mit <strong>metadata journaling</strong>, das mit einem
robusten Funktionsumfang kommt und auf Skalierbarkeit ausgelegt ist.
    </li>
    <li>
<ref iref="IBM-JFS" chapter="dateisysteme_journaling">JFS</ref>
ist IBMs Hochleistungs Journaling Dateisystem. Es ist vor kurzem
einsatzbereit geworden. Es gibt allerdings noch keine ausreichende
Erfahrungen, so dass seine allgemeine Stabilität an diesem Punkt weder
positiv noch negativ kommentiert werden kann.
    </li>
   </ul>

   <section>
    <heading>
Erstellen eines ext2 Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>
    
    <shell>
     <root>
mkfs.ext2 /dev/hda1
     </root>
    </shell>
   </section>

   <section>
    <heading>
Erstellen eines ext3 Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>

    <shell>
     <root>
mkfs.ext3 /dev/hda1
     </root>
    </shell>

    <textblock>
oder
    </textblock>

    <shell>
     <root>
mkfs.ext2 -j /dev/hda1
     </root>
    </shell>

    <textblock>
Der Parameter -j schaltet das Journaling ein.
    </textblock>
   </section>

   <section>
    <heading>
Erstellen eines ReiserFS Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>

    <shell>
     <root>
mkfs.reiserfs /dev/hda1
     </root>
    </shell>
   </section>

   <section>
    <heading>
Erstellen eines Reiser4 Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>

    <shell>
     <root>
mkfs.reiser4 /dev/hda1
     </root>
    </shell>
   </section>

   <section>
    <heading>
Erstellen eines XFS Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>
    
    <shell>
     <root>
mkfs.xfs /dev/hda1
     </root>
    </shell> 
   </section>

   <section>
    <heading>
Erstellen eines JFS Dateisystems
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda1</path>
    </textblock>

    <shell>
     <root>
mkfs.jfs /dev/hda1
     </root>
    </shell>
   </section>

   <section>
    <heading>
Erstellen eines swap Bereichs
    </heading>

    <textblock>
Der Aufruf zum Formatieren lautet für <path>/dev/hda2</path>
    </textblock>

    <shell>
     <root>
mkswap /dev/hda2
     </root>
    </shell>
    
    <textblock>
Der Aufruf zum Einbinden der swap Partition lautet für <path>/dev/hda2</path>
    </textblock>

    <shell>
     <root>
swapon /dev/hda2
     </root>
    </shell>
   </section>
  </section>
 </split>
</chapter>
